#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度简单1854收藏分享切换为英文接收动态反馈

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

### 双指针迭代

我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。
第二个指针 cur 指向 head，然后不断遍历 cur。
每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。

![迭代.gif](https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
     ListNode prev =null;
     ListNode curr =head;
     while(curr !=null){
         //curr下一个为nextTemp
         //记录当前节点的下一个节点
         ListNode nextTemp=curr.next;
         //cur指向了prev
         ////然后将当前节点指向pre
         curr.next=prev;
         //pre和cur节点都前进一位
         prev=curr;
         curr=nextTemp;
     }
        return prev;
    }
}


```

### 递归

1. 终止条件是当前节点或者下一个节点==null
2. 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句
3. ![递归.gif](https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif)

```java
class Solution {
	public ListNode reverseList(ListNode head) {
		//递归终止条件是当前为空，或者下一个节点为空
		if(head==null || head.next==null) {
			return head;
		}
		//这里的cur就是最后一个节点
		ListNode cur = reverseList(head.next);
		//这里请配合动画演示理解
		//如果链表是 1->2->3->4->5，那么此时的cur就是5
		//而head是4，head的下一个是5，下下一个是空
		//所以head.next.next 就是5->4
		head.next.next = head;
		//防止链表循环，需要将head.next设置为空
        //断掉4->5
		head.next = null;
		//每层递归函数都返回cur，也就是最后一个节点
		return cur;
	}
}

```

### 栈

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode resListNode = new ListNode(0) ;
        //承接压栈ListNode head的临时变量
        ListNode pListNode = head;
        //接收弹出的链表
        ListNode res = resListNode;
        Stack<Integer> st =  new Stack<Integer>();
        //压栈
        while(pListNode!=null) {
        	st.push(pListNode.val);
        	pListNode = pListNode.next;
        }
        //弹出
        while(!st.empty()) {
            //peek方法是返回栈顶的元素但不移除它
        	res.next = new ListNode(st.peek());
        	st.pop();
        	res = res.next;
        }
        return resListNode.next;
    }
}
```

