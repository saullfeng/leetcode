#### [274. H 指数](https://leetcode-cn.com/problems/h-index/)

难度中等216收藏分享切换为英文接收动态反馈

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

[h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （`n` 篇论文中）**总共**有 `h` 篇论文分别被引用了**至少** `h` 次。且其余的 *`n - h`* 篇论文每篇被引用次数 **不超过** *`h`* 次。

例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。

**提示：**如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**示例 2：**

```
输入：citations = [1,3,1]
输出：1
```

 

**提示：**

- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`

### 排序

首先我们可以将初始的 H 指数 h 设为 0，然后将引用次数排序，并且对排序后的数组从大到小遍历。

根据 H 指数的定义，如果当前 H 指数为 hh 并且在遍历过程中找到当前值 citations[i]>h，则说明我们找到了一篇被引用了至少 h+1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int h =0, i= citations.length-1;
        while (i >= 0 && citations[i] > h) {
            h++;
            i--;
        }
        return h;
    }
}
```

时间复杂度：(nlogn)，其中 n 为数组 citations 的长度。即为排序的时间复杂度。

空间复杂度：O(logn)，其中 n 为数组 citations 的长度。即为排序的空间复杂度。

### 计数排序

根据上述解法我们发现，最终的时间复杂度与排序算法的时间复杂度有关，所以我们可以使用计数排序算法，新建并维护一个数组 counter 用来记录当前引用次数的论文有几篇。

根据定义，我们可以发现 H 指数不可能大于总的论文发表数，所以对于引用次数超过论文发表数的情况，我们可以将其按照总的论文发表数来计算即可。这样我们可以限制参与排序的数的大小为 [0,n][0,n]（其中 n 为总的论文发表数），使得计数排序的时间复杂度降低到 O(n)。

最后我们可以从后向前遍历数组 counter，对于每个0≤i≤n，在数组 counter 中得到大于或等于当前引用次数 i 的总论文数。当我们找到一个 H 指数时跳出循环，并返回结果。

```java
public class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length, tot = 0;
        int[] counter = new int[n + 1];
        for (int i = 0; i < n; i++) {
            if (citations[i] >= n) {
                counter[n]++;
            } else {
                counter[citations[i]]++;
            }
        }
        for (int i = n; i >= 0; i--) {
            tot += counter[i];
            if (tot >= i) {
                return i;
            }
        }
        return 0;
    }
}
```

时间复杂度：O(n)，其中 n 为数组 citations 的长度。需要遍历数组 citations 一次，以及遍历长度为 n+1 的数组 counter 一次。

空间复杂度：O(n)，其中 n 为数组 citations 的长度。需要创建长度为 n+1n+1 的数组 counter。

### 二分

根据题意，我们需要找到满足条件「**引用次数至少为 x 次的 x 篇论文」中的最大 x 值**。

那么在以最大值 x 为分割点的正整数数轴上，满足二段性：

少于等于 x 的数值必然满足条件；
大于 x的数值必然不满足。

因此我们可以通过二分在 [0, n][0,*n*] 范围内找分割点 x

```java
class Solution {
    public int hIndex(int[] citations) {
        int n =citations.length;
        int l=0,r=n;
        while(l<r){
            int mid =l+r+1>>1;
            if(check(cs,mid))l=mid;
            else r=mid-1;
        }
    }
    boolean check(int[] cs, int mid){
        int ans =0;
        for(int i:cs)if(i>mid) ans++;
        return ans>=mid;
    }
}
```

时间复杂度：对 [0, n][0,n] 做二分，复杂度为 O(logn)；check 函数需要对数组进行线性遍历，复杂度为 O(n)。整体复杂度为O(nlogn)
空间复杂度：O(1)

