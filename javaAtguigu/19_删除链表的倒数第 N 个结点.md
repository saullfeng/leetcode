#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

难度中等1496收藏分享切换为英文接收动态反馈

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

### 快慢指针

我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。

由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。

具体地，初始时first 和second 均指向头节点。我们首先使用 first 对链表进行遍历，遍历的次数为 n。此时，first 和 second 之间间隔了 n-1n−1 个节点，即 first 比second 超前了 nn个节点。

在这之后，我们同时使用 first 和 second 对链表进行遍历。当 first 遍历到链表的末尾（即 first 为空指针）时，second 恰好指向倒数第 n 个节点。

根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 second 指向哑节点，其余的操作步骤不变。这样一来，当first 遍历到链表的末尾时，second 的下一个节点就是我们需要删除的节点。






![p3](https://assets.leetcode-cn.com/solution-static/19/p3.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode first =head;
        ListNode second =dummy;
        //first先走n布
        for(int i =0;i<n;i++){
            first=first.next;
        }
        //first与second共走 直到first到null
        while(first !=null){
            first=first.next;
            second=second.next;
        }
        //断开倒数第n的节点连接
        second.next=second.next.next;
        //返回更新的链表
        ListNode ans =dummy.next;
        return ans;
    }
    
}
```

- 时间复杂度：O(L)，其中 *L* 是链表的长度。
- 空间复杂度：O(1)

### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

![img](https://assets.leetcode-cn.com/solution-static/19/8.png)

【peek】找到但不移除此列表的头(第一个元素)。

【pop】移除顶对象并作为此函数的值返回该对象。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        Duque<ListNode> stack =new LinkedList<>();
        ListNode cur= dummy;
        while(cur !=null){
            stack.push(cur);
            cur = cur.next;
        }
        //将倒数第n个数至于栈顶
        for(int i = 0;i< n;i++){
            stack.pop();
        }
        //peek栈顶标记为prev
        ListNdoe prev =stack.peek();
        //断开倒数第n的节点连接
        prev.next =prev.next.next;
        ListNode ans =dummy.next;
        return ans;
    }
}
```

- 时间复杂度：O(L)，其中 L是链表的长度。
- 空间复杂度：O(L)，其中 L是链表的长度。主要为栈的开销。