#### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

难度中等325收藏分享切换为英文接收动态反馈

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

### 桶排序

由于每个字符在字符串中出现的频率存在上限，因此可以使用桶排序的思想，根据出现次数生成排序后的字符串。具体做法如下：

遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq；

创建桶，存储从 1 到maxFreq 的每个出现频率的字符；

按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。

getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值

```java
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer> map =new HashMap<Character,Integer>();
        //出现最多的元素c
        int maxFreq =0;
        int length =s.length();
        //遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq
        for(int i=0;i<length;i++){
            char c =s.charAt(i);
            //每个元素c 出现的次数 频率
            int frequency =map.getOrDefault(c,0)+1;
            map.put(c,frequency);
            //maxFreq
            maxFreq=Math.max(maxFreq,frequency);
        }
               //创建桶，存储从 1 到maxFreq 的每个出现频率的字符 创建了到maxFreq+1个桶
        StringBuffer[] buckets=new StringBuffer[maxFreq+1];
        for(int i=0;i<=maxFreq;i++){
            buckets[i]=new StringBuffer();
        }
        //按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符
        for(Map.Entry<Character,Integer> entry: map.entrySet()){
            char c= entry.getKey();
            int frequency =entry.getValue();
            buckets[frequency].append(c);
        }
        //然后将每个字符按照出现频率拼接到排序后的字符串
        //反转拼接 i第几个桶 j桶里第几个元素
        StringBuffer res =new StringBuffer();
        for(int i=maxFreq;i>0;i--){
            StringBuffer bucket =buckets[i];
            int size =bucket.length();
            for(int j=0;j<size;j++){
                for(int k=0;k<i;k++){
                    res.append(bucket.charAt(j));
                }
            }
        }
        return res.toString();
    }
}
```

时间复杂度：O(n+k)，其中 nn 是字符串 s的长度，k 是字符串 ss 包含的不同字符的个数。
遍历字符串统计每个字符出现的频率需要 O(n)的时间。
创建桶并将不同字符加入桶需要 O(k)的时间。
生成排序后的字符串，需要 O(k)的时间遍历桶，以及 O(n)的时拼接字符串间。
因此总时间复杂度是 O(n+k)。

空间复杂度：O(n+k)，其中 n 是字符串 s的长度，kk 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于桶和生成的排序后的字符串。

### 数据结构 + 模拟

1. 先使用「哈希表」对词频进行统计；
2. 遍历统计好词频的哈希表，将每个键值对以 `{字符,词频}` 的形式存储到「优先队列（堆）」中。并规定「优先队列（堆）」排序逻辑为

如果 词频 不同，则按照 词频 倒序；
如果 词频 相同，则根据 字符字典序 升序（由于本题采用 Special Judge 机制，这个排序策略随意调整也可以。但通常为了确保排序逻辑满足「全序关系」，这个地方可以写正写反，但理论上不能不写，否则不能确保每次排序结果相同）

 3.从「优先队列（堆）」依次弹出，构造答案。

```java
class Solution {
    class Node {
        char c; 
        int v;
        Node(char _c, int _v) {
            c = _c; v = _v;
        }
    }
    public String frequencySort(String s) {
        char[] cs = s.toCharArray();
        Map<Character, Integer> map = new HashMap<>();
        for (char c : cs) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        PriorityQueue<Node> q = new PriorityQueue<>((a,b)->{
            if (b.v != a.v) return b.v - a.v;
            return a.c - b.c;
        });
        for (char c : map.keySet()) {
            q.add(new Node(c, map.get(c)));
        }
        StringBuilder sb = new StringBuilder();
        while (!q.isEmpty()) {
            Node poll = q.poll();
            int k = poll.v;
            while (k-- > 0) sb.append(poll.c);
        }
        return sb.toString();
    }
}


```

时间复杂度：令字符集的大小为 C。使用「哈希表」统计词频的复杂度为 O(n)；最坏情况下字符集中的所有字符都有出现，最多有 C个节点要添加到「优先队列（堆）」中，复杂度为 O(ClogC)；构造答案需要从「优先队列（堆）」中取出元素并拼接，复杂度为 O(n)。整体复杂度为 O(max(n,ClogC))
空间复杂度：O(n)



###数组实现 + 模拟

思路同上

具体的，利用 ASCII 字符集共 128位，预先建立一个大小为 128的数组，利用「桶排序」的思路替代「哈希表」和「优先队列（堆）」的作用。

```java
class Solution {
    public String frequencySort(String s) {
        int[][] cnts =new int[128][2];
        char[] cs =s.toCharArray();
        //类似桶
        for(int i=0;i<128;i++){
            cnts[i][0]=i;
        }
        //将字符串 cs[]拆解成字符装进cnts
        for(char c:cs)cnts[c][1]++;
        //排序  如果 词频 不同，则按照 词频 倒序；
//如果 词频 相同，则根据 字符字典序 升序
        Arrays.sort(cnts,(a,b) ->{
            if(a[1] !=b[1]) return b[1]-a[1];
            return a[0]-b[0];
        });
        StringBuilder res =new StringBuilder();
        for(int i=0;i<128;i++){
            char c =(char)cnts[i][0];
            int k=cnts[i][1];
            while(k-- >0) res.append(c);
        }
        return res.toString();
    }
}
```

时间复杂度：令字符集的大小为 C。复杂度为 O(max(n,ClogC))
空间复杂度：(n+C+logC)

排序之后

![image-20210806170118347](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210806170118347.png)

