#### [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

难度简单262收藏分享切换为英文接收动态反馈

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

整数 `n` 是 4 的幂次方需满足：存在整数 `x` 使得 `n == 4x`

 

**示例 1：**

```
输入：n = 16
输出：true
```

**示例 2：**

```
输入：n = 5
输出：false
```

**示例 3：**

```
输入：n = 1
输出：true
```

 

**提示：**

- `-231 <= n <= 231 - 1`

 ### 取模性质

如果 n*n* 是 44 的幂，那么它可以表示成 4^x4*x* 的形式，我们可以发现它除以 33 的余数一定为 11，即：

4^*x*≡(3+1)^*x*≡1^*x*≡1(mod 3)

如果 n 是 2 的幂却不是 4 的幂，那么它可以表示成 4^x 2 的形式，此时它除以 3 的余数一定为 2。

因此我们可以通过 n 除以 3 的余数是否为 1 来判断 n 是否是 4 的幂。

(n&(n-1))==0判断是否为2的幂次方

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n> 0&&(n&(n-1))==0 && n%3==1;
    }
}
```

- 时间复杂度：O(1)

- 空间复杂度：O(1)

  ### sqrt+lowbit

  如果 nn 是 44 的幂，那么 nn 的二进制表示中有且仅有一个 11，并且这个 11 出现在从低位开始的第偶数个二进制位上（这是因为这个 11 后面必须有偶数个 00）。这里我们规定最低位为第 00 位，例如 n=16n=16 时，nn 的二进制表示为

  (10000)_2

  唯一的 11 出现在第 44 个二进制位上，因此 n*n* 是 44 的幂。


lowbit(x) ：是求二进制中最低位1对应的值。

lowbit(x) = x&(~x+1)或x&(-x)

~5+1 -> 1011

![image-20210811204313054](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210811204313054.png)

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if(n<=0)return false;
        int x=Math.sqrt(n);
        return x*x==n && (x & -x) == x;
    }
}
```

时间复杂度：复杂度取决于内置函数 sqrt。一个简单的 sqrt 的实现接近于 P2 的代码。复杂度为 O(logn)
空间复杂度：O(1)

