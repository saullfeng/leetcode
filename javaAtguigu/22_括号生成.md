

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 

示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：

输入：n = 1
输出：["()"]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-parentheses

### 回溯法+剪枝

```java
    // 回溯法
    public List<String> generateParenthesis(int n) {
        if (n == 0) return null;
        List<String> res = new ArrayList<>();
        backtracke(new StringBuilder(), 0, 0, res, n);
        return res;
    }

    // 回溯
    public void backtracke(StringBuilder cur, int left, int right, List<String> res, int n) {

        // 递归结束条件。括号组合为2 * n才是合法的
        if (cur.length() == n * 2) {
            res.add(cur.toString());
            return;
        }

        // 左括号需要n个，若不足，则每次添加一个左括号，
        if (left < n) {
            // 添加左括号
            cur.append("(");
            // 每次添加后左括号数加一
            backtracke(cur, left + 1, right, res, n);
            cur.deleteCharAt(cur.length() - 1);
        }
        // 右括号的数量小于左括号时，每次添加一个右括号
        if (right < left) {
            // 添加右括号
            cur.append(")");
            // 每次添加后右括号数加一
            backtracke(cur, left, right + 1, res, n);
            // 撤销
            cur.deleteCharAt(cur.length() - 1);
        }
    }

```

### dfs

```java
    //DFS
    public List<String> generateParenthesis(int n) {
    	if (n <= 0) return null;
    	
        List<String> res = new ArrayList<>();
        dfs("", n, n, res);
        return res;
    }

    /*
        dfs
        参数：cur: 当前加入的串，
              left: (的数量
              right: )的数量
              res: 返回的串
    */
    public void dfs(String cur, int left, int right, List<String> res) {
        if (left == 0 && right == 0) {
            res.add(cur);
            return;
        }
        // 剪枝（左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
        if (left > right) return;

        // left > 0 说明左括号的数量多于右括号的数量，所以每次左括号的数量-1才能和右括号匹配
        if (left > 0) {
            dfs(cur + "(", left - 1, right, res);
        }
        // right > 0 说明右括号的数量多于左括号的数量，所以每次右括号的数量-1才能和左括号匹配
        if (right > 0) {
            dfs(cur + ")", left, right - 1, res);
        }
    }

```

