#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

难度中等839收藏分享切换为英文接收动态反馈

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```



### 按照「方向」进行模拟

事实上，我们还可以根据「方向」进行模拟。

因为每一圈的打印输出都是按照特定的「四个方向」进行的。

这种解法更为简洁。而触发方向转换的时机：

下一步发生位置溢出
回到了本圈的起点

![image.png](https://pic.leetcode-cn.com/1615771940-ngackL-image.png)

```java
class Solution {
    //标记位
    int INF=101;
    public List<Integer> spiralOrder(int[][] mat) {
        //接收集合
        List<Integer> ans = new ArrayList<>();
        //行 列
       int m = mat.length, n = mat[0].length;
        //四个方向
        int[][] dirs=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};
        for(int x =0,y=0,d=0,i=0;i<m*n;i++){
            ans.add(mat[x][y]);
            //走过之后标记为INF
            mat[x][y]=INF;
            
            // 下一步要到达的位置
            int nx =x+dirs[d][0], ny=y+dirs[d][1];
            // 如果下一步发生「溢出」或者已经访问过（说明四个方向已经走过一次）
            if(nx <0 ||nx>=m||ny<0||ny>=n||mat[nx][ny] ==INF){
                d=(d+1) % 4;
                nx =x+dirs[d][0];
                ny=y+dirs[d][1];
            }
            x=nx;
            y=ny;
        }
        return ans;
      

    }
      
}
```

- 时间复杂度：O(n * m)
- 空间复杂度：O(1）