#### [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

难度简单224收藏分享切换为英文接收动态反馈

在 MATLAB 中，有一个非常有用的函数 `reshape` ，它可以将一个 `m x n` 矩阵重塑为另一个大小不同（`r x c`）的新矩阵，但保留其原始数据。

给你一个由二维数组 `mat` 表示的 `m x n` 矩阵，以及两个正整数 `r` 和 `c` ，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的 **行遍历顺序** 填充。

如果具有给定参数的 `reshape` 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg)

```
输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg)

```
输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]
```

 

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 100`
- `-1000 <= mat[i][j] <= 1000`
- `1 <= r, c <= 300`

### 二维数组的一维表示 暴力法

对于一个行数为 m，列数为 n，行列下标都从 00 开始编号的二维数组，我们可以通过下面的方式，将其中的每个元素 (i, j)(i,j) 映射到整数域内，并且它们按照行优先的顺序一一对应着 [0, mn) 中的每一个整数。形象化地来说，我们把这个二维数组「排扁」成了一个一维数组。

这样的映射即为：

(*i*,*j*)→*i*×*n*+*j*

同样地，我们可以将整数 xx 映射回其在矩阵中的下标，即


i=x / n
j=x % n



那么题目需要我们做的事情相当于：

- 将二维数组 nums映射成一个一维数组；
- 将这个一维数组映射回 r 行 c 列的二维数组

我们当然可以直接使用一个一维数组进行过渡，但我们也可以直接从二维数组 nums 得到 r 行 c 列的重塑矩阵：

设 nums 本身为 m 行 n 列，如果 mn /rc，那么二者包含的元素个数不相同，因此无法进行重塑；否则，对于 x∈[0,mn)，第 x 个元素在nums 中对应的下标为 (x / n,x % n)，而在新的重塑矩阵中对应的下标为(x / c,x % c)。我们直接进行赋值即可。

```java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m=mat.length;
        int n=mat[0].length;

        if(m*n != r*c){
            return mat;
        }
        int[][] ans =new int[r][c];
        for(int x =0;x <m*n;x++){
            ans[x/c][x%c] =mat[x/n][x%n];
        }
        return ans;

    }
}
```

时间复杂度：O(rc)。这里的时间复杂度是在重塑矩阵成功的前提下的时间复杂度，否则当 mn /rc

 =rc 时，\C++ 语言中返回的是原数组的一份拷贝，本质上需要的时间复杂度为 O(mn)，而其余语言可以直接返回原数组的对象，需要的时间复杂度仅为O(1)。

空间复杂度O(1)。这里的空间复杂度不包含返回的重塑矩阵需要的空间

。

### 暴力法

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int or = nums.length, oc = nums[0].length;
        if (or * oc != r * c) return nums;
        int[][] ans = new int[r][c];
        for (int i = 0, idx = 0; i < or; i++) {
            for (int j = 0; j < oc; j++, idx++) {
                ans[idx / c][idx % c] = nums[i][j];
            }
        }
        return ans;
    }
}


```

- 时间复杂度：O(r * c)
- 空间复杂度：O(1)