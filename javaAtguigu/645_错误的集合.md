#### [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

难度简单223收藏分享切换为英文接收动态反馈

集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

### 计数

一个朴素的做法是，使用「哈希表」统计每个元素出现次数，然后在 [1, n][1,n] 查询每个元素的出现次数。

在「哈希表」中出现 2 次的为重复元素，未在「哈希表」中出现的元素为缺失元素。

由于这里数的范围确定为 [1, n][1,n]，我们可以使用数组来充当「哈希表」，以减少「哈希表」的哈希函数执行和冲突扩容的时间开销。

集合 `s` 包含从 `1` 到 `n` 的整数

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n=nums.length;
        int[] cnts=new int[n+1];
        //重复值加1
        for(int x:nums)cnts[x]++;
        int[] ans =new int[2];
        for(int i=1;i<=n;i++){
            //缺失的值显现
            if(cnts[i]==0)ans[1]=i;
            //重复的值显现
            if(cnts[i]==2)ans[0]=i;
        }
        return ans;
    }
}
```

哈希表

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] errorNums = new int[2];
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int i = 1; i <= n; i++) {
            int count = map.getOrDefault(i, 0);
            if (count == 2) {
                errorNums[0] = i;
            } else if (count == 0) {
                errorNums[1] = i;
            }
        }
        return errorNums;
    }
}


```

时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组并填入哈希表，然后遍历从 1 到 n 的每个数寻找错误的集合。

空间复杂度：O(n)，其中 n 是数组nums 的长度。需要创建大小为O(n) 的哈希表。





### 数学

我们还可以利用数值范围为 [1, n][1,n]，只有一个数重复和只有一个缺失的特性，进行「作差」求解。

令 [1, n][1,n] 的求和为 tot，这部分可以使用「等差数列求和公式」直接得出：tot=n(1+n) /2  ；
**令数组 nums 的求和值为 sum**，由循环累加可得；
**令数组 sums 去重求和值为se**t，由循环配合「哈希表/数组」累加可得

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n =nums.length;
        int[] cnts = new int[n+1];
        int tot = (1+n) * n /2;
        int sum = 0,set = 0;
        for(int x : nums){
            sum += x;
            //cnts[x] == 0去重
            if(cnts[x] == 0) set += x;
            //标定值 缺失值cnts[]为0
            cnts[x] = 1;
        }
        //重复值sum-set 缺失值tot-set
        return new int[]{sum-set,tot-set};
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 桶排序

因为值的范围在 [1, n][1,n]，我们可以运用「桶排序」的思路，根据 **nums[i] = i + 1**的对应关系使用 O(n) 的复杂度将每个数放在其应该落在的位置里。

然后线性扫描一遍排好序的数组，找到不符合 nums[i]=i+1 对应关系的位置，从而确定重复元素和缺失元素是哪个值。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        for(int i =0 ;i < n ; i++){
            //防止顺序错乱例如 {1,1,4,3}->{1,1,3,4}
            while(nums[i] != i+1 && nums[nums[i] - 1] !=nums[i]){
           swap(nums, i , nums[i] - 1);     
            }
        }
        int a = -1, b = -1;
        //然后线性扫描一遍排好序的数组，找到不符合 nums[i] = i + 1nums[i]=i+1 对应关系的位置，从而确定重复元素和缺失元素是哪个值
        for(int i = 0; i < n; i++){
            if(nums[i] != i + 1){
                a = nums[i];
                b = i == 0 ? 1 : nums[i-1] + 1;
            }
        }
        return new int[]{a,b};
    }
    void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)