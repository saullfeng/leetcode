#### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

难度中等698收藏分享切换为英文接收动态反馈

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

 

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

**示例 2：**

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

 

**提示：**

- `1 <= n <= 1690`

### 最小堆

要得到从小到大的第 nn 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 11 加入堆。

每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x2x,3x,5x 也是丑数，因此将 2x, 3x, 5x2x,3x,5x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 nn 次从最小堆中取出的元素即为第 nn 个丑数。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] factors ={2,3,5};
        //防止重复的set
        Set<Long> seen =new HashSet<Long>();
        PriorityQueue<Long> heap =new PriorityQueue<>();
        seen.add(1L);
        heap.offer(1L);
        int ugly =0;
        for(int i =0;i<n;i++){
            long curr =heap.poll();
            ugly=(int)curr;
            for(int factor:factors){
                long next =curr*factor;
                //set中加入queue中的next
                //if(seen.add(next)){
                if(!seen.contains(next)){
                    seen.add(next);
                    heap.offer(next);
                }
            }
        }
     return ugly;
    }
}
```

时间复杂度：O(n \log n)。得到第 nn个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 O(\log 3n + 3 \log 3n)=O(logn)，总时间复杂度是 O(n \log n)。

空间复杂度：O(n)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3n。

### 动态规划


	


```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for (int i = 2; i <= n; i++) {
            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(num2, num3), num5);
            if (dp[i] == num2) {
                p2++;
            }
            if (dp[i] == num3) {
                p3++;
            }
            if (dp[i] == num5) {
                p5++;
            }
        }
        return dp[n];
    }
}


```

