#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

难度中等1248收藏分享切换为英文接收动态反馈

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

通过次数191,677

提交次数514,705

题目理解

{1，2，3，4}的下一个排序就是这四个数的更大排序=>{1,2,4,3}

如果没有更大的排序则为升序排列如实例2

**我们结合样例来分析，假设样例为 `[1,3,5,4,1]`：**

**从后往前找，找到第一个下降的位置，记为 k。注意k 以后的位置是降序的。 在样例中就是找到 3**

**从 k 往后找，找到最小的比 k 要大的数。 找到 4**

**将两者交换。注意此时 k 以后的位置仍然是降序的。**

**直接将 k 以后的部分翻转（变为升序）。**

即两遍扫描法

注意：如果在步骤 1 中找到头部还没找到，说明该序列已经是字典序最大的排列。按照题意，我们要将数组重新排列成最小的排列。

### 两遍扫描

```java
class Solution {
    public void nextPermutation(int[] nums) {
           int n =nums.length;
        int k=n-1;
        //从末位开始查找不符合降序的数值 一个没有则全员升序
        while(k-1>=0 && nums[k -1] >= nums[k])k--;
        if(k==0){
            reverse(nums,0,n-1);
        }else{
            //此时的k锚定 降序数中最大值
            //如{1,2,3,6,5,4}的6
            //{1,4,2,3,6,5,4,3}的6
            int u =k;
            //u是查找 最小的比 k 大的数
            while(u+1<n&& nums[u+1] >nums[k-1])u++;
            swap(nums,k-1,u);
            //反转
            reverse(nums,k,n-1);
        }
    }
    
    //交换
    public void swap(int[] nums,int a,int b){
        int c= nums[a];
        nums[a]=nums[b];
        nums[b]=c;
    }
    //反转 k位之后反转
    public void reverse(int[] nums,int a, int b){
        int l=a,r=b;
        while(l<r){
            swap(nums,l++,r--);
        }
    }
}
```

- 时间复杂度：对数组线性遍历。复杂度为 O(n)
- 空间复杂度：O(1)