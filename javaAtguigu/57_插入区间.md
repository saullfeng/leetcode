



#### [57. 插入区间](https://leetcode-cn.com/problems/insert-interval/)

难度中等453收藏分享切换为英文接收动态反馈

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

**示例 2：**

```
输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
```

**示例 3：**

```
输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
```

**示例 4：**

```
输入：intervals = [[1,5]], newInterval = [2,3]
输出：[[1,5]]
```

**示例 5：**

```
输入：intervals = [[1,5]], newInterval = [2,7]
输出：[[1,7]]
```

### 排序法

太慢

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
       if(intervals.length==0) return new int[][]{newInterval};
       ArrayList<int[]> res=new ArrayList<>();
       ArrayList<int[]> temp=new ArrayList<>();
       for(int[] interval:intervals){
           temp.add(interval);
       }
        temp.add(newInterval);
        temp.sort((x,y)->x[0]-y[0]);
        for(int[] interval:temp){
            int[] lastResult=res.size()==0?new int[]{-1,-1}:res.get(res.size()-1);
        if(res.size()==0||lastResult[1]<interval[0]){
            res.add(interval);
        }else{
            lastResult[1]=Math.max(lastResult[1],interval[1]);
        }
        }
        return res.toArray(new int[res.size()][2]);
    }
}
```

分段

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> list=new ArrayList<>();
        int len =intervals.length;
        // intervals的索引
        int index=0;
        // 步骤一：找到需要合并的区间
        while(index<len&&intervals[index][1]<newInterval[0]){
            list.add(intervals[index]);
            index++;
        }
       // 步骤二：合并区间
          while(index<len&&newInterval[1]>=intervals[index][0]){
               // 与插入区间有交集，计算它们的并集
            newInterval[0]=Math.min(newInterval[0],intervals[index][0]);
            newInterval[1]=Math.max(newInterval[1],intervals[index][1]);
            index++;
        }
        list.add(newInterval);
         // 步骤三：处理合并区间之后的区间
        while(index<len){
            list.add(intervals[index]);
            index++;
        }
        return list.toArray(new int[][]{});
    }
}
```

