#### [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

难度中等1226收藏分享切换为英文接收动态反馈

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

 

**示例 1：**

```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**

```
输入：s = "A", numRows = 1
输出："A"
```

 ### 按行排序

```java
class Solution {
    public String convert(String s, int numRows) { 
        if(numRows <2) return s;
        List<StringBuilder> rows =new ArrayList<StringBuilder>();
        for(int i=0;i<numRows;i++) rows.add(new StringBuilder());
        //i第几行 flag临时变量 指向条件行
        int i=0,flag=-1;
        for(char c: s.toCharArray()){
            rows.get(i).append(c);
            //numRows-1最后一行 i==0第一行
            if(i==0||i==numRows-1)  flag=-flag;
            //换行 最后一行-1 第一行加1
                i+=flag;
        }
        StringBuilder res =new StringBuilder();
        for(StringBuilder row:rows) res.append(row);
        return res.toString();
        
   
    }
}
```



- 时间复杂度：分别对 `s` 中的每个字符进行打印。复杂度为 O(n)
- 空间复杂度：O(n)

### 按行访问

首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推...

对于所有整数 k，

行 0 中的字符位于索引 k(2⋅numRows−2) 处;
行 numRows−1 中的字符位于索引 k*(2⋅numRows−2) +numRows−1 处;
内部的 行 ii中的字符位于索引k(2⋅numRows−2)+i 以及 (k+1)(2⋅numRows−2)−i 处;



```java
class Solution {
    public String convert(String s, int numRows) {

        if (numRows == 1) return s;

        StringBuilder ret = new StringBuilder();
        int n = s.length();
        //中间行
        int cycleLen = 2 * numRows - 2;

        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j + i < n; j += cycleLen) {
                ret.append(s.charAt(j + i));
                //numRows-1最后一行 i==0第一行
                //内部行（不一定是一行 j + cycleLen - i < n）
                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)
                    ret.append(s.charAt(j + cycleLen - i));
            }
        }
        return ret.toString();
    }
}


```

时间复杂度：O(n)，其中 n == len(s)。每个索引被访问一次。
空间复杂度：O(n)。对于 C++ 实现，如果返回字符串不被视为额外空间，则复杂度为 O(1)。

### 数学规律

我们可以不失一般性的将规律推导为「首项」和「公差公式」。

这通常能够有效减少一些判断。

分情况讨论：

- 对于第一行和最后一行：公差为 `2 * (n − 1)` 的等差数列，首项是 `i`

- 对于其他行：两个公差为 `2 * (n − 1)` 的等差数列交替排列，首项分别是 `i` 和 `2 * n − i − 2`

```java
class Solution {
    public String convert(String s, int numRows) {
        int n = s.length();
        if(numRows<2) return s;
        StringBuilder res=new StringBuilder();
        for(int i=0;i<numRows;i++){
            //对于第一行和最后一行
           if (i == 0 || i == numRows - 1) {
                //临时指针
                int pos =i;
                int offset=2*(numRows -1);
                while(pos <n){
                    res.append(s.charAt(pos));
                    pos+=offset;
                }
                
            }else{
                int pos1 =i, pos2=2*numRows-i+2;
                int offset=2*(numRows -1);
                while(pos1<n||pos2<n){
                    if(pos1<n){
                        res.append(s.charAt(pos1));
                        pos1=offset;
                    }
                       if (pos2 < n) {
                        res.append(s.charAt(pos2));
                        pos2 += offset;
                    }
                }
            }
        }
return res.toString();
    }
}


```

- 时间复杂度：分别对 `s` 中的每个字符进行打印。复杂度为 O(n)
- 空间复杂度：O(1)

优化

```java
class Solution {
    public String convert(String s, int r) {
        int n = s.length();
        if (n == 1 || r == 1) return s;

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < r; i++) {
            if (i == 0 || i == r - 1) {
                int pos = i;
                int offset = 2 * (r - 1);
                while (pos < n) {
                    sb.append(s.charAt(pos));
                    pos += offset;
                }
            } else {
                int pos1 = i, pos2 = 2 * r - i - 2;
                int offset = 2 * (r - 1);
                while (pos1 < n || pos2 < n) {
                    if (pos1 < n) {
                        sb.append(s.charAt(pos1));
                        pos1 += offset;
                    }
                    if (pos2 < n) {
                        sb.append(s.charAt(pos2));
                        pos2 += offset;
                    }
                }
            }
        }
        return sb.toString();
    }
}


```

