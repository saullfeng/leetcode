#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000

### 暴力法

由上面案例需求可知, 此题目的是让我们求出连续数组中任意一个连续的数字组合, 并且这个连续的数字组合的相加之和是所有数字组合中
最大的.

我们可以很容易想到双重遍历数组进行暴力求解; 外层循环我们从0–>nums.length, 目的是遍历每一个索引i; 内层循环我们从 i–>nums.length, 在每一i下的内循环中, 我们从i开始直到数组末尾, 每一次相加都是以nums[i]为开头对应的连续子串的组合, 所以利用这个方法, 我们可以通过记录最大和sumMax来循序渐进的找出最大的子序和;

```java
public class Solution {
    //暴力解法
    /**
     * 1. 遍历待排数组, 遍历一个就加一次, 把这个和保存在变量maxSum中,
     * 2. 每一次加法都要与maxSum比较, 大的话就更新这个变量的值, 小于或等于就不变
     * 3. 等到遍历完毕后, 返回这个maxSum
     */
    public static int maxSubArray(int[] nums) {
        int len = nums.length;
        int sum;
        //剪枝
        if(len == 1) return nums[0];

        //双重循环, 外层循环控制每个相加子串的开始位置. 比如 i=2, 那么子串就从2往后, 不断的增长到n, 途中进行加操作
        //        内层循环, 从i开始往后一个一个的相加, 每加上一个数, 就与之前的加结果进行比较
        int maxSum = Integer.MIN_VALUE;
        for(int i=0; i < len; i++){
            sum = 0;
            for(int j=i; j < len; j++){
                 sum = sum + nums[j];
                 maxSum = Math.max(sum, maxSum);
            }
        }
        return maxSum;
    }

    public static void main(String[] args) {
        int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
        System.out.println(maxSubArray(nums));
    }
}


```

### 分治法

[思路分析]

分治法就是将整个数组切分为几个小组, 每个小组然后再切分为几个更小的小组, 一直到不能继续切分也就是只剩一下一个数字为止. 然后每个小组会计算出最优值, 汇报给上一级的小组, 一级一级汇报, 上级拿到下级的汇报找到最大值, 得到最终的结果. 和合并排序的算法类似, 先切分, 再合并结果;

这个问题的关键就是如何切分这些组合才能使每个小组之间不会有重复的组合(有重复的组合意味着有重复的计算量.)

首先是切分分组方法, 举例: [-2, 1, -3, 4, -1, 2, 1, -5, 4], 一共有9个元素, 我们首先中值切分 mid = (start+end)/2, 得到中间元素的索引为4, 也就是-1, 切分后我们会得到三个组合:

[-2, 1, -3, 4, -1] 以及他们的子序列(在中值-1的左边并且包含中值的为一组);
[2, 1, -5, 4]以及他们的子序列(在中值-1的右边且不包含它的为一组);
我们的连续子序列还可能是跨中值的组合, 比如-1的左边有几个值, 右边也有几个值, 组合起来的最大子序和是最大的. 所以我们需要把任何包含中值-1以及他右边元素2的序列为一组(换言之就是包含左边序列的最右边元素以及右边序列最左边元素(就是nums[mid] 和 nums[mid+1])的序列为一组), 比如: [4, -1, 2, 1]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dR50PmA2-1625128433553)(2021-06-04-11-08-25.png)]

[实现方案]

以上的三个组合内的序列没有任何的重复的部分，而且一起构成所有子序列的全集，计算出这个三个子集合的最大值，然后取其中的最大值，就是这个问题的答案了。

然而前两个子组合可以用递归来解决，一个函数就搞定，第三个跨中心的组合应该怎么计算最大值呢？

答案就是先计算左边序列里面的包含最右边元素的子序列的最大值，也就是从左边序列的最右边元素向左一个一个累加起来，找出累加过程中每次累加的最大值，就是左边序列的最大值。

同理找出右边序列的最大值，就得到了右边子序列的最大值。左右两边的最大值相加，就是包含这两个元素的子序列的最大值。

在计算过程中，累加和比较的过程是关键操作，一个长度为 n 的数组在递归的每一层都会进行 n 次操作，分治法的递归层级在 logNlogN 级别，所以整体的时间复杂度是 O(nlogn)O(nlogn)，在时间效率上不如动态规划的 O(n)O(n) 复杂度。

```java
package LeetCodeDemo.lt53;
//分治法求最大子序和
public class Solution_A {
    // 分为了两段, (start--> mid) 和 (mid+1--> end)
    public static int maxSubArray(int[] nums) {
        return maxSubArrayWithBorder(0, nums.length-1, nums);
    }

    public static int maxSubArrayWithBorder(int start, int end, int[] nums){
        //递归出口
        if(start == end) return nums[start];

        int mid = (start + end)/2;
        //分
        int leftMax = maxSubArrayWithBorder(start, mid, nums);
        int rightMax = maxSubArrayWithBorder(mid+1,  end, nums);

        //治(计算)
        //1. 计算左半部分的和(从start--> mid)
//        int leftMaxSum = nums[start];
//        int sumA = 0;
//        for(int i=start; i <= mid; i++){
//            sumA = sumA + nums[i];
//            leftMaxSum = Math.max(sumA, leftMaxSum);
//        }
        int leftMaxSum = nums[mid];
        int sumA = 0;
        for(int i=mid; i>=start; i--){
            sumA = sumA + nums[i];
            leftMaxSum = Math.max(sumA, leftMaxSum);
        }
        //2. 计算右半部分的和(从mid+1--> end)
        int rightMaxSum = nums[mid+1];
        int sumB = 0;
        for(int j=mid+1; j <= end; j++){
           sumB = sumB + nums[j];
           rightMaxSum = Math.max(sumB, rightMaxSum);
        }

        //3. 计算跨越中值的和
        int crossSum = leftMaxSum + rightMaxSum;

        //递归完成后, 我们每一次的左半部分的和, 有半部分的和, 跨越中值的和都会在这里比较
        return Math.max(crossSum, Math.max(leftMax, rightMax));
    }

    public static void main(String[] args) {
        int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
        System.out.println(maxSubArray(nums));
    }

}

```

### 动态规划

思路：
之前在网上看到过一段话，理科的东西不像是文科的东西，需要有一定的感悟或者是一定的艺术熏陶才能理解。理科的东西很多时候都是固定的。很多答案都比较经典。所有不存在理解不了。也许只要换一种表述就能理解。
按照暴力法的求解思路，遍历所有的组合，选择其中的最优解。

通常遍历子序列有三种方式遍历
以一个节点为开头遍历所有的子序列:用题目中的例子举例。
eg[-2] , [-2,1] , [-2,1,-3] 遍历完所有以 -2 开头的子序列 然后开始遍历以 1 开头的子序列[1] , [1,-3],....。
按照序列的长度遍历，如先遍历长度为一的序列，然后遍历长度为2 的等等。
按照序列的结束为基准，先遍历出某个节点为结束的所有子序列。因为每个节点都有可能是子序列的结束节点。eg以1 为结束的所有子序列[-2] , [-2,1]
第一种的遍历方式通常用于暴力解法。第二种遍历方式可以用于回文,第三种遍历方式通常用于动态规划。
原因是应为动态规划的核心，找到不同子序列之间的递推关系。

综上：我们按照第三种遍历的方式的话 可以得出结果 第 i 位置上的组合有 i 种。如果有 9 个数字的话按照排列组合的算法有 45 个组合。遍历这些组合需要 两层循环 时间复杂度

动态规划的三个核心

步骤
step1
1 开始找最优子结构 以 -2 为结尾的子组合 第一个单元格表示 组合的大小为一的时侯 和最大是多少

![img](https://img-blog.csdnimg.cn/20200228133032662.png)

显然和最大是 -2

![img](https://img-blog.csdnimg.cn/20200228133433126.png)

2 第二个子组合是已第二个数字为结尾的连续序列 也就是 [-2 ,1] [1]

![img](https://img-blog.csdnimg.cn/20200228133938453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdydWkxNjA1,size_16,color_FFFFFF,t_70)

最大值是1 第一个单元格表示组合的大小为一的时侯最大值是1 第二个单元格表示组合大小为2 的时候最大值是1

3 第三个子组合是以第三个数字结尾的连续序列，也就是 [-2,1,3], [1,3], [3]，最大值4

![img](https://img-blog.csdnimg.cn/20200228134535266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdydWkxNjA1,size_16,color_FFFFFF,t_70)

这里的组合三 可以分成两种情况

继承组合二得到的序列，组合二[-2,1] [1] 继承后 [-2 ,1 ,3] [1,3] 最大值 = 第二组的最大值 + 第三个数字
单独第三个数字的序列，也就是[3] 最大值 = 第三个数字
按照这样推如果能得到每个子组合的最优解，也就是子序列的最大值，整体的最大值就可以通过比较这九个子组合的最大值来得到。这样我们就找到了最优子问题。和重叠问题

step2 状态转移方程

![img](https://img-blog.csdnimg.cn/20200228135955684.png)

step3 状态压缩 优化空间
每次状态更新 只依赖前一个状态。

```java
public class Solution {

    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int[] dp = new int[len];
        dp[0] = nums[0];
        for (int i = 1; i < len; i++) {
            if (dp[i - 1] >= 0) {
                dp[i] = dp[i - 1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
        }
        求最大值
        int res = dp[0];
        for (int i = 1; i < len; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

}

```

简化（贪心算法）

思路
这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来
动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果
时间复杂度：O(n)O(n)
代码



```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}

作者：guanpengchn
链接：https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/

```

