#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等630收藏分享切换为英文接收动态反馈

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

### 回溯+剪枝

标签：回溯与剪枝
n 表示范围为 1...n，balance 表示剩余空间，m表示开始位置，tmp 为回溯列表
判断 balance == 0，如果为 0 则代表 tmp中已经存入 k 个数，拷贝 list 存入结果 ans 中
如果不为 0，从 m 位置开始递归调用，现将当前位置数据加入 list 中，并进入下一层，等待返回后将本层加入的数据移除，本质就是树的构造过程
其中循环结束条件默认为最大值到 n，这里可以优化进行剪枝，比如 n=4，k=3 时，如果列表从 m=3 也就是 [3] 开始，那么该组合一定不存在，因为至少要 k=3 个数据，所以剪枝临界点为 n-balance+1

![image.png](https://pic.leetcode-cn.com/3ddd55697423b5831cbbd42f4b901ebbade0daa456c651a70c758fe359d8a0d1-image.png)

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        //组合集
        ArrayList<List<Integer>> res = new ArrayList<>();
        //组合
        ArrayList<Integer> tmp = new ArrayList<>();
        // 从 1 开始是题目的设定
        getCombine(res, tmp, n, k, 1);
        return res;
     }
    //从哪里开始查 1查完 查2 3 4
    public void getCombine(List<List<Integer>> res, List<Integer> tmp, int n, int k, int m) {
        //终止条件
        if(tmp.size() == k) {
            //复制 避免引用传递
            res.add(new ArrayList(tmp));
            return;
        }
        //剪枝：temp 长度加上区间 [m, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        //搜索起点和当前还需要选几个数有关
        //temp.size() + (n - m + 1) < k
        //m为起始位置
        for(int i = m; i <= n-k+tmp.size()+1; i++){
            tmp.add(i);
             // 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            getCombine(res, tmp, n, k, i+1);
            // 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作
            tmp.remove(tmp.size()-1);
        }
    }
}

```

![image-20210818101426782](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210818101426782.png)
