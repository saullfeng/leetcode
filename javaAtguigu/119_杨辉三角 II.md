#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

难度简单314收藏分享切换为英文接收动态反馈

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: rowIndex = 3
输出: [1,3,3,1]
```

**示例 2:**

```
输入: rowIndex = 0
输出: [1]
```

**示例 3:**

```
输入: rowIndex = 1
输出: [1,1]
```

 

**提示:**

- `0 <= rowIndex <= 33`

 

**进阶：**

你可以优化你的算法到 `*O*(*rowIndex*)` 空间复杂度吗？

![image-20210812114950994](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812114950994.png)

### 递推

![image-20210812115042431](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812115042431.png)

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<List<Integer>> C = new ArrayList<List<Integer>>();
        //第i行
        for (int i = 0; i <= rowIndex; ++i) {
            List<Integer> row = new ArrayList<Integer>();
            //j 是 第i行第j个元素
            for (int j = 0; j <= i; ++j) {
                //首项 末项
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    row.add(C.get(i - 1).get(j - 1) + C.get(i - 1).get(j));
                }
            }
            C.add(row);
        }
        return C.get(rowIndex);
    }
}
```



优化

注意到对第 i+1行的计算仅用到了第 i 行的数据，因此可以使用**滚动数组**的思想优化空间复杂度

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> pre = new ArrayList<Integer>();
        for (int i = 0; i <= rowIndex; ++i) {
            List<Integer> cur = new ArrayList<Integer>();
            for (int j = 0; j <= i; ++j) {
                if (j == 0 || j == i) {
                    cur.add(1);
                } else {
                    cur.add(pre.get(j - 1) + pre.get(j));
                }
            }
            pre = cur;
        }
        return pre;
    }
}
```

**进一步优化**

![image-20210812115722784](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812115722784.png)

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<Integer>();
        row.add(1);
        for (int i = 1; i <= rowIndex; ++i) {
            row.add(0);
            for (int j = i; j > 0; --j) {
                row.set(j, row.get(j) + row.get(j - 1));
            }
        }
        return row;
    }
}
```

![image-20210812115841393](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812115841393.png)







### 线性递推

![image-20210812115910800](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812115910800.png)

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<Integer>();
        row.add(1);
        for (int i = 1; i <= rowIndex; ++i) {
            row.add((int) ((long) row.get(i - 1) * (rowIndex - i + 1) / i));
        }
        return row;
    }
}
```

![image-20210812115931705](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210812115931705.png)