#### [480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

难度困难303收藏分享切换为英文接收动态反馈

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

- `[2,3,4]`，中位数是 `3`
- `[2,3]`，中位数是 `(2 + 3) / 2 = 2.5`

给你一个数组 *nums*，有一个长度为 *k* 的窗口从最左端滑动到最右端。窗口中有 *k* 个数，每次窗口向右移动 *1* 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

**示例：**

给出 *nums* = `[1,3,-1,-3,5,3,6,7]`，以及 *k* = 3。

```
窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
```

 因此，返回该滑动窗口的中位数数组 `[1,-1,-1,3,5,6]`。

 

**提示：**

- 你可以假设 `k` 始终有效，即：`k` 始终小于等于输入的非空数组的元素个数。
- 与真实值误差在 `10 ^ -5` 以内的答案将被视作正确答案。

### 朴素解法

个直观的做法是：对每个滑动窗口的数进行排序，获取排序好的数组中的第 `k / 2` 和 `(k - 1) / 2` 个数（避免奇偶数讨论），计算中位数

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int cnt = n - k + 1;
        double[] ans = new double[cnt];
        int[] t = new int[k];
        for (int l = 0, r = l + k - 1; r < n; l++, r++) {
            for (int i = l; i <= r; i++) t[i - l] = nums[i];
            Arrays.sort(t);
            ans[l] = (t[k / 2] / 2.0) + (t[(k - 1) / 2] / 2.0);
        }
        return ans;
    }
}

```

时间复杂度：最多有 n 个窗口需要滑动计算。每个窗口，需要先插入数据，复杂度为O(k)，插入后需要排序，复杂度为 O(klogk)。整体复杂度为O(n∗(k+klogk))
空间复杂度：使用了长度为 k 的临时数组。复杂度为O(k)

### 优先队列（堆）解法

其实我们需要的就是滑动窗口中的第 `k / 2` 小的值和第 `(k - 1) / 2` 小的值。

我们知道滑动窗口求最值的问题，可以使用优先队列来做。

但这里我们求的是第 `k` 小的数，而且是需要两个值。还能不能使用优先队列来做呢？

我们可以维护两个堆：

一个大根堆维护着滑动窗口中一半较小的值（此时堆顶元素为滑动窗口中的第 (k - 1) / 2 小的值）
一个小根堆维护着滑动窗口中一半较大的值（此时堆顶元素为滑动窗口中的第 k / 2 小的值）

滑动窗口的中位数就是两个堆的堆顶元素的平均值

实现细节：

1.初始化时，先让 k 个元素直接入 right，再从 right 中倒出 k / 2 个到 left 中。这时候可以根据 left 和 right 得到第一个滑动窗口的中位值。

2.开始滑动窗口，每次滑动都有一个待添加和待移除的数：

2.1 根据与右堆的堆顶元素比较，决定是插入哪个堆和从哪个堆移除

2.2 之后调整两堆的大小（确保只会出现 left.size() == right.size() 或 right.size() - left.size() == 1，对应了窗口长度为偶数或者奇数的情况）

2.3 根据 left 堆 和 right 堆得到当前滑动窗口的中位值

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {

    }
}
```

时间复杂度：调整过程中堆大小最大为 k，堆操作中的指定元素删除复杂度为 O(k)；窗口数量最多为 n。整体复杂度为 O(n * k)
空间复杂度：最多有 n 个元素在堆内。复杂度为 O(n)

