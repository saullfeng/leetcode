#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

难度简单1054收藏分享切换为英文接收动态反馈

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

### 双指针

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

一个指向头，一个指尾

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
      if(head==null||head.next==null){
          return true;
      }
        ArrayList<Integer> res =new ArrayList<>();
        while(head!=null){
            res.add(head.val);
            head=head.next;
        }
        int left=0;
        int right=res.size()-1;
        while(left<right){
            //判断头尾是否相等
            if(!res.get(left).equals(res.get(right))){
                return false;
            }
                left++;
                right--;
            
        }
         return true;
    }
}
```

![image-20210820110519681](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820110519681.png)

### 栈

- 遍历链表，把每个节点都push到`stack`中。
- 再次遍历链表，同时节点依次出栈，二者进行比较。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null){
          return true;
      }
       ListNode temp =head;
        Stack<Integer> stack =new Stack<>();
        while(temp!=null){
            stack.push(temp.val);
            temp=temp.next;
        }
        while(head!=null&& !stack.isEmpty()){
            if(head.val!=stack.pop()){
                return false;
            }
            head=head.next;
        }
        return true;
    }
}
```

![image-20210820111219891](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820111219891.png)

### 递归（递归加上双指针）

回文链表 前后对应一致 p指向开头 recursion递归至链尾

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    //全局指针p
    ListNode p =new ListNode();
    public boolean isPalindrome(ListNode head) {
        //赋予了新的链表 p
        p=head;
        return recursion(head);
    }
    public boolean recursion(ListNode head){
        //第一步
        if(head==null){
            return true;
        }
        //递归至链尾
        //返回上一步（第一步）
        if(!recursion(head.next)){
            return false;
        }
        //p是新的链表
        if(p.val!=head.val){
            return false;
        }
        p=p.next;
        //满足true 递归返回上层的值
        //????
        return true;
    }
}
```

![image-20210820110946238](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820110946238.png)

### 快慢指针

慢指针进一步

快指针进两步，当快指针到头，反转慢指针到快指针之间的区间

![image-20210820110750804](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820110750804.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
          if(head==null||head.next==null){
          return true;
      }
        ListNode slow =head;
        ListNode fast =head;
        //定义快慢指针速度
        //奇数时 slow在中间 fast在末尾
        while(fast !=null&& fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }
        //偶数时 slow在mid右边 fast在开头
        if(fast!=null){
            slow=slow.next;
        }
        fast=head;
        ListNode reversedList=
            reversedList(slow);
        while(reversedList !=null){
            if(fast.val != reversedList.val){
                return false;
            }
            fast=fast.next;
            reversedList= reversedList.next;
            
        }
        return true;
        

    }
    //链表反转
    public ListNode reversedList(ListNode head){
        ListNode previous =null;
        ListNode current =head;
        while(current !=null){
            ListNode next =current.next;
            current.next =previous;
            previous =current;
            current =next;
        }
        return previous;
    } 
}
```

![image-20210820110808571](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820110808571.png)
