#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

难度中等696收藏分享切换为英文接收动态反馈

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

### 暴力法

首先最容易想到的是暴力求解，使用两个 for 循环，一个 for 循环固定一个数字比如 m，另一个 for 循环从 m 的下一个元素开始累加，当和大于等于 s 的时候终止内层循环，顺便记录下最小长度

```java
    public int minSubArrayLen(int target, int[] nums) {
        int n=nums.length;
        if(n==0)return 0;
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            int sum = nums[i];
            if (sum >=target)
                return 1;
            for (int j = i + 1; j < n; j++) {
                //连续
                sum += nums[j];
                if (sum >= target) {
                    //并更新子数组的最小长度（此时子数组的长度是 j-i+1j−i+1）
                    min = Math.min(min, j - i + 1);
                    break;
                }
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }


```

### 双指针  滑动窗口

接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。

所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。

![209.长度最小的子数组.gif](https://pic.leetcode-cn.com/1626251110-hOsxXM-209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

我们把数组中的元素不停的入队，直到总和大于等于 s 为止，接着记录下队列中元素的个数，然后再不停的出队，直到队列中元素的和小于 s 为止（如果不小于 s，也要记录下队列中元素的个数，这个个数其实就是不小于 s 的连续子数组长度，我们要记录最小的即可）。接着再把数组中的元素添加到队列中……重复上面的操作，直到数组中的元素全部使用完为止。
这里以 [2,3,1,2,4,3] 举例画个图来看下

![image.png](https://pic.leetcode-cn.com/10ca012c2f0170afcac5e5996add20c32c36a82f4bb4a6187897bb948ace5fe2-image.png)

![image.png](https://pic.leetcode-cn.com/2da8cf86a2a3df3c95ed7d95add574dca2d8bae8420addd0fa6b8c55fa3db081-image.png)

![image.png](https://pic.leetcode-cn.com/ca74b1a2ad0eb5a4ebf8647a332161b140c8ebdd71cd5d19bef16e9bf0a43c95-image.png)

![image.png](https://pic.leetcode-cn.com/72f39b5cd7eb5f866e24d0a31eb3eac7d57cf3ad202ad40d30f103833c1f5a69-image.png)

上面画的是使用队列，但在代码中我们不直接使用队列，我们使用两个指针，一个指向队头一个指向队尾，我们来看下代码





```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            //查到合适的
            while (sum >= target) {
                //减除
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}

```

变换成加法

```java
   class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        int start = 0, end = 0;
        
        while (end<n) {
            target -= nums[end];
            end++;
            while (target <= 0) {
                min = Math.min(min, end - start);
               target += nums[start];
                start++;
            }
            
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
    
   }

```

