#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等2671收藏分享切换为英文接收动态反馈

给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

 以x轴为高  y为底更好理解

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**示例 3：**

```
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4：**

```
输入：height = [1,2,1]
输出：2
```

 

**提示：**

- `n = height.length`
- `2 <= n <= 3 * 104`
- `0 <= height[i] <= 3 * 104`

### 暴力法

我们可以直接枚举所有的情况：先枚举确定左边界，再往右枚举确定右边界。

然后再记录枚举过程中的最大面积即可：

例如 int[] h ={1,3,1,2}; 1x1 1x3 1x2 3x1 3x2 1x2

枚举出最大值

```java
class Solution {
    public int maxArea(int[] height) {
        int len = height.length;
        int ans = 0;

        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                int h = j - i;
                int w = Math.min(height[i], height[j]);
                ans = Math.max(w * h, ans);
            }
        }
        return ans;
    }
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

### 双指针+ 贪心

先用两个指针 `i` 和 `j` 指向左右边界，然后考虑指针应该怎么移动

由于构成矩形的面积，取决于 `i` 和 `j` 之间的距离（记为 `w`） 和 `i` 和 `j` 下标对应的高度的最小值（记为 `h`）

首先无论是 `i` 指针往右移动还是 `j` 指针往左移动都会导致 `w` 变小，所以想要能够枚举到更大的面积，**我们应该让 `h` 在指针移动后变大**。

- 对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。左边界向右 右边界向左

所以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值

```java
class Solution {
    public int maxArea(int[] height) {
        int len = height.length;
        int l=0,r=len-1;
        int ans = 0;
        while(l<r){
            //ans = Math.max(ans, (r - l) * Math.min(height[i], height[j]));
            int area =Math.min(height[l],height[r])*(r-l);
            ans=Math.max(ans,area);
            //对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃
            if(height[l]<=height[r]){
                ++l;
            }else{
                --r;
            }
        }
return ans;
    }
}
```

- 时间复杂度：会对整个数组扫描一遍。复杂度为 O(n)
- 空间复杂度：O(1)