#### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

难度中等918收藏分享切换为英文接收动态反馈

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且不重复的四元组 `[nums[a], nums[b], nums[c], nums[d]]` ：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

 

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

 

**提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`

### 排序 + 双指针解法

这道题的思路和「15. 三数之和（中等）」、「16. 最接近的三数之和（中等）」类似。

对数组进行排序，使用四个指针 i、j 、k 和 p 分别代表要找的四个数。

通过枚举 i 确定第一个数，枚举 j 确定第二个数，另外两个指针 k 和 p 分别从左边 j + 1 和右边 n - 1 往中间移动，找到满足 nums[i] + nums[j] + nums[k] + nums[p] == t 的所有组合。

k 和 p 指针的移动逻辑，分情况讨论 sum = nums[i] + nums[j] + nums[k] + nums[p] ：

sum > target：p 左移，使 sum 变小
sum < target：k 右移，使 sum 变大
sum = target：将组合加入结果集，k 右移继续进行检查
题目要求不能包含重复元素，所以我们要对 i、j 和 k 进行去重，去重逻辑是对于相同的数，只使用第一个。



```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int t) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) { // 确定第一个数
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 对第一个数进行去重（相同的数只取第一个）
            for (int j = i + 1; j < n; j++) { // 确定第二个数
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; // 对第二个数进行去重（相同的数只取第一个）
                // 确定第三个数和第四个数
                int k = j + 1, p = n - 1;
                while (k < p) {
                
                    // 对第三个数进行去重（相同的数只取第一个）
                    while (k > j + 1 && k < n && nums[k] == nums[k - 1]) k++; 
                    // 如果 k 跳过相同元素之后的位置超过了 p，本次循环结束
                    if (k >= p) break;
                    
                    int sum = nums[i] + nums[j] + nums[k] + nums[p];
                    if (sum == t) {
                        ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[p]));
                        k++;
                    } else if (sum > t) {
                        p--;
                    } else if (sum < t) {
                        k++;
                    }
                }
            }
        }
        return ans;
    }
}
```

时间复杂度：i 和 j 是直接枚举确定，复杂度为 O(n^2) 当确定下来 i 和 j 之后，通过双指针确定 k 和 p ，也就是对于每一组 i 和 j 而言复杂度为 O(n)O(n)。总的复杂度为 O(n^3)
空间复杂度：O(n ^ 2)

### 回溯DFS

首先将数组 nums 升序排序，并把答案四元组中**没确定**的个数设为 n

我把剪枝分为了 4 类，括号内的是用什么完成剪枝

1.如果剩余可选的数字数量**少于 n，**则剪掉（递归返回）；
2.每层递归的 for 循环中，从第二轮循环开始，如果数组中当前数字和前一个相同，则剪掉（进行下一次循环，这条的任务就是**去重**）；

3.如果 当前数字 + 已确定数字的和 + (n - 1) * 排序后数组中当前数字的下一个数字 **> target**当前数字+已确定数字的和+(n−1)∗排序后数组中当前数字的下一个数字>target，则说明后面的数无论怎么选，加起来都一定大于 target，所以剪掉（递归返回）；

4.如果 当前数字 + 已确定数字的和 + (n - 1) * 排序后数组最后一个数字 < target当前数字+已确定数字的和+(n−1)∗排序后数组最后一个数字**<target**，则说明后面的数无论怎么选，加起来都一定小于 target，所以剪掉（进行下一次循环）。

这里解释一下第 3、4 条
由于我们已经对数组进行了升序排序，所以右边数字大于等于左边数字；另外，我们找数是从数组中的某一点开始往右找，不会往左找，起点的位置也是依次往右走的。以上两条是大前提。

对于第 3 条，假设要找的四个数都还没确定，现在想要把脚标为i的数字（记为 nums[i]）加入答案中。为了避免无用功，在加入之前先瞅一眼，如果 nums[i] 加上它右边数字的三倍之后大于目标值，说明就算后面所有数字都相等，也不可能在 nums[i]的右边找到另外三个数加上 nums[i]的和等于目标值。而且如果进行下一轮循环让 i 往右移动，由于数组递增，就更不可能找到四个数加起来等于目标值了，所以直接递归返回，而不是进行下一轮循环。

对于第 4 条，依然假设要找的四个数都还没确定，现在想要把脚标为 i 的数字（记为 nums[i]）加入答案中。加入之前也要先瞅一眼，如果 nums[i] 加上数组最后一个数字（也就是数组中最大的那个）的三倍之后仍小于目标值，说明就算后面所有数字都相等，都是最大值，也不可能在 nums[i]的右边找到另外三个数加上 nums[i]的和等于目标值。但是与上面不同的是，由于数组递增，进行下一轮循环后 nums[i] 会变大，整体的和也会变大，这样就有可能找到四个数加起来等于目标值了，所以是进行下一轮循环，而不是递归返回。

上面说的都是基于没有已确定数字，如果有已确定数字那么可以依此类推，将倍数改成两倍、一倍就行了。

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
    int cur = 0;
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        dfs(nums, target,0);
        return ans;
    }
    void dfs(int[] nums, int target, int begin){
        if(list.size() == 4){
            if(cur == target){
                ans.add(new ArrayList<>(list));
            }
            return;
        }
//1 2 3 4
        for(int i = begin; i < nums.length; i++ ){
            if(nums.length - i  < 4 - list.size())return;
            if(begin != i && nums[i - 1] == nums[i])continue;
            if(i < nums.length - 1 && cur + nums[i] + (3 - list.size()) * nums[i + 1] > target)return;
            if(i < nums.length - 1 && cur + nums[i] + (3 - list.size()) * nums[nums.length - 1] < target)continue;
            cur += nums[i];
            list.add(nums[i]);
            dfs(nums, target, i + 1);
            list.remove(list.size() - 1);
            cur -= nums[i];
        }
    }
}

```

