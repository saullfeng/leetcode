

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度中等5840收藏分享切换为英文接收动态反馈

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0
```

### 暴力法

**直觉**

逐个检查所有的字符串，看它是否不含有重复的字符。

**算法**

假设我们有一个函数`boolean allUnique(String substring)` ，如果子字符串中的字符都是唯一的，它会返回true，否则会返回false。 我们可以遍历给定字符串`s`的所有可能的子字符串并调用函数`allUnique`。 如果事实证明返回值为true，那么我们将会更新无重复字符子串的最大长度的答案。

现在让我们填补缺少的部分：

1. 为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 i 和 j。那么我们有 0≤i<j≤n （这里的结束索引 j 是按惯例排除的）。因此，使用 i从0到 n - n−1 以及 j 从 i+1到 n这两个嵌套的循环，我们可以枚举出`s`的所有子字符串。
2. 要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入`set`中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回`false`。循环结束后，我们返回`true`

```java
//提交超时
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0)
            return 0;
        int max=1;
        for(int i=0;i<s.length();++i){
            for(int j=i+1;j<s.length();++j){
                if(j-i+1<=max)
                    continue;
                String temp=s.substring(i,j+1);
                if(allUnique(temp))
                    max=temp.length();
            }
        }
        return max;
    }
    public boolean allUnique(String s){
        char[] chs=s.toCharArray();
        Map<Character,Integer> map=new HashMap<>();
        for(int i=0;i<chs.length;++i){
            if(map.containsKey(chs[i]))
                return false;
            map.put(chs[i],i);
        }
        return true;
    }
}

```

**复杂度分析：**

![img](https://images2018.cnblogs.com/blog/1294992/201806/1294992-20180602155955649-1013849852.png)

### 滑动窗口

定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
我们定义不重复子串的开始位置为 start，结束位置为 end
随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
无论是否更新 start，都会更新其 map 数据结构和结果 ans。



```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n=s.length(),ans=0;
        
        Map<Character,Integer>map=new HashMap<>();
        for(int end=0, start=0;end<n;end++){
            //向右滑动
            char alpha =s.charAt(end);
            //如果相同
            if(map.containsKey(alpha)){
                //start  指向重复位置重新开始
                start=Math.max(map.get(alpha),start);
            }
            //记录最长位置
            ans=Math.max(ans,end-start+1);
            //没有重复则map记录
            map.put(s.charAt(end),end+1);
        }
        return ans;

    }
}


```

![img](https://images2018.cnblogs.com/blog/1294992/201806/1294992-20180602160515493-702182763.png)

![img](https://images2018.cnblogs.com/blog/1294992/201806/1294992-20180602160601018-121811122.png)

简化

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n=s.length(),ans=0;
        
        Map<Character,Integer>map=new HashMap<>();
        for(int end=0, start=0;end<n;end++){
            char alpha =s.charAt(end);
            if(map.containsKey(alpha)){
                start=Math.max(map.get(alpha)+1,start);
            }
            ans=Math.max(ans,end-start+1);
            map.put(alpha,end);
        }
        return ans;

    }
}

```

