#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

难度困难2286收藏分享切换为英文接收动态反馈

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3：**

```
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

**示例 4：**

```
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5：**

```
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```

### 动态规划



动态规划的边界条件为 [0][0]=true，(j即p从下标1开始)即两个空字符串是可以匹配的。最终的答案即为 f[m][n]，其中 m和 n分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。

这里的情况分类与解法1类似，不过此时是向前看，具体如下：
(1) 若 p[j-1] == ‘*’，则考虑 ‘*’ 的匹配次数：
a. s[i-1] 可被匹配，即 p[j-2]==s[i-1] 或 p[j-2]==‘.’，此时 ‘*’ 可匹配多次或 0 次；
b. s[i-1] 不可被匹配，此时 ‘*’ 只能匹配 0 次。
(2) 若 p[j-1] != ‘*’，则直接匹配 s[i-1] 与 p[j-1]，此时的两种情况较为简单：
a. s[i] 可被匹配，即 p[j-1]==s[i-1] 或 p[j-1]==‘.’，则继续递归；
b. s[i] 不可被匹配，则赋值 False，由于初始化时已为 False，可不做操作。

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
![image.png](https://pic.leetcode-cn.com/1624002820-nJsTlf-image.png)

以String p去匹配s

```
String s="aab";
String p=".c*a*b";
```

. 匹配a .c匹配a .c*匹配a ...   .c*a*b匹配a ...  .c*a*b匹配aab

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m=s.length();
        int n=p.length();
        //n为行 m为列
        boolean[][] f=new boolean[m+1][n+1];
        //初始化
        f[0][0]=true;
        //推导
        for(int i=0;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(p.charAt(j-1)=='*'){
                    f[i][j]=f[i][j-2];
                    if(matches(s,p,i,j-1)){
                        f[i][j]=f[i][j] ||f[i-1][j];
                    }
                }else{
                    if(matches(s,p,i,j)){
                        f[i][j]=f[i-1][j-1];
                    }
                }
            }
        }
        return f[m][n];
    }
    public boolean matches(String s,String p,int i,int j){
        if(i==0) return false;
        if(p.charAt(j-1)=='.')return true;
        return s.charAt(i-1)==p.charAt(j-1);
    }
}
```

时间复杂度：O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。

空间复杂度：O(mn)，即为存储所有状态使用的空间。

