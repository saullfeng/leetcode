#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

难度中等1060收藏分享切换为英文接收动态反馈

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

### 动态规划

![image-20210822111717713](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822111717713.png)

```go
func uniquePaths(m int, n int) int {
    dp :=make([][]int ,m)
    // 初始化
    for i:=range dp{
        dp[i]=make([]int,n)
        dp[i][0] =1
    }
    // 初始化
    for j:=0;j<n;j++{
        dp[0][j] =1
    }
    // 推导出 dp[i][j] = dp[i-1][j] + dp[i][j-1];
    for i:=1;i<m;i++{
        for j :=1;j<n;j++{
            dp[i][j] =dp[i-1][j]+dp[i][j-1]
        }
    } 
    // f(0,0)=1 推导出 dp[m-1][n-1]
    return dp[m-1][n-1]
}
```

时间复杂度：O(mn)。

空间复杂度：O(mn)，即为存储所有状态需要的空间。注意到 f(i,j) 仅与第 i 行和第i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为O(n)。此外，由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m 和 n 使得 m≤n，这样空间复杂度降低至 O(min(m,n))。

### 数学组合

![image-20210822111809611](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822111809611.png)

```go
func uniquePaths(m, n int) int {
    //二项式
    return int(new(big.Int).Binomial(int64(m+n-2), int64(n-1)).Int64())
}
```

时间复杂度：O(m)。由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m 和 n 使得 m≤n，这样空间复杂度降低至 O(min(m,n))。

空间复杂度：O(1)。

