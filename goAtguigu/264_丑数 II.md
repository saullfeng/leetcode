#### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

难度中等698收藏分享切换为英文接收动态反馈

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

 

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

**示例 2：**

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

 

**提示：**

- `1 <= n <= 1690`

### 最小堆

要得到从小到大的第 n 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x也是丑数，因此将 2x, 3x, 5x加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。

```go
var factors = []int{2, 3, 5}

type hp struct{ sort.IntSlice }
func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }
func (h *hp) Pop() interface{}   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }

func nthUglyNumber(n int) int {
    //set
    h := &hp{sort.IntSlice{1}}
    //队列
    seen := map[int]struct{}{1: {}}
    for i := 1; ; i++ {
        x := heap.Pop(h).(int)
        if i == n {
            return x
        }
        for _, f := range factors {
            next := x * f
            if _, has := seen[next]; !has {
                heap.Push(h, next)
                seen[next] = struct{}{}
            }
        }
    }
}
```

时间复杂度：O(n \log n)。得到第 nn个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 O(\log 3n + 3 \log 3n)=O(logn)，总时间复杂度是 O(n \log n)。

空间复杂度：O(n)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3n。

### 动态规划


​	![image-20210820115610503](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820115610503.png)


```go
func nthUglyNumber(n int) int {
    dp := make([]int, n+1)
    dp[1] = 1
    p2, p3, p5 := 1, 1, 1
    for i := 2; i <= n; i++ {
        x2, x3, x5 := dp[p2]*2, dp[p3]*3, dp[p5]*5
        dp[i] = min(min(x2, x3), x5)
        if dp[i] == x2 {
            p2++
        }
        if dp[i] == x3 {
            p3++
        }
        if dp[i] == x5 {
            p5++
        }
    }
    return dp[n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

```

![image-20210820115618734](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820115618734.png)

```go
var dp [1700]int
func nthUglyNumber(n int) int {
	// 6/2 5/3 5/5
	// 1 2 3 4 5 6 7 8 9  10
	// 1 2 3 4 5 6 8 9 10 12
	// [0 1 2 3 4 5 6 8 9 10 9 12 15 16 15 18 15 15]
    dp = [1700]int{0, 1}
	p2 := 1; p3 := 1; p5 := 1
	for i := 2; i <= n; i ++ {
		val2 := dp[p2] * 2
		val3 := dp[p3] * 3
		val5 := dp[p5] * 5
		dp[i] = min(min(val2, val3), val5)
		if dp[i] == val2 {
			p2 ++
		}
		if dp[i] == val3 {
			p3 ++
		}
		if dp[i] == val5 {
			p5 ++
		}
	}

	return dp[n]
}

func min(a, b int) int {
	if a < b {
		return a
	}

	return b
}

```

