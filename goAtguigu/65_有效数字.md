- #### [65. 有效数字](https://leetcode-cn.com/problems/valid-number/)

  难度困难273收藏分享切换为英文接收动态反馈

  **有效数字**（按顺序）可以分成以下几个部分：

  1. 一个 **小数** 或者 **整数**
  2. （可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**

  **小数**（按顺序）可以分成以下几个部分：

  1. （可选）一个符号字符（`'+'` 或 `'-'`）
  2. 下述格式之一：
     1. 至少一位数字，后面跟着一个点 `'.'`
     2. 至少一位数字，后面跟着一个点 `'.'` ，后面再跟着至少一位数字
     3. 一个点 `'.'` ，后面跟着至少一位数字

  **整数**（按顺序）可以分成以下几个部分：

  1. （可选）一个符号字符（`'+'` 或 `'-'`）
  2. 至少一位数字

  部分有效数字列举如下：

  - `["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]`

  部分无效数字列举如下：

  - `["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]`

  给你一个字符串 `s` ，如果 `s` 是一个 **有效数字** ，请返回 `true` 。

   

  **示例 1：**

  ```
  输入：s = "0"
  输出：true
  ```

  **示例 2：**

  ```
  输入：s = "e"
  输出：false
  ```

  **示例 3：**

  ```
  输入：s = "."
  输出：false
  ```

  **示例 4：**

  ```
  输入：s = ".1"
  输出：true
  ```

   

  **提示：**

  - `1 <= s.length <= 20`
  - `s` 仅含英文字母（大写和小写），数字（`0-9`），加号 `'+'` ，减号 `'-'` ，或者点 `'.'` 。





### 确定有限状态自动机

![image-20210825140500860](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210825140500860.png)

![image-20210825140513384](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210825140513384.png)

![image-20210825140532514](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210825140532514.png)

![image-20210825140550020](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210825140550020.png)

绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。

```go
type State int
type CharType int

const (
    STATE_INITIAL State = iota
    STATE_INT_SIGN
    STATE_INTEGER
    STATE_POINT
    STATE_POINT_WITHOUT_INT
    STATE_FRACTION
    STATE_EXP
    STATE_EXP_SIGN
    STATE_EXP_NUMBER
    STATE_END
)

const (
    CHAR_NUMBER CharType = iota
    CHAR_EXP
    CHAR_POINT
    CHAR_SIGN
    CHAR_ILLEGAL
)

func toCharType(ch byte) CharType {
    switch ch {
    case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
        return CHAR_NUMBER
    case 'e', 'E':
        return CHAR_EXP
    case '.':
        return CHAR_POINT
    case '+', '-':
        return CHAR_SIGN
    default:
        return CHAR_ILLEGAL
    }
}

func isNumber(s string) bool {
    transfer := map[State]map[CharType]State{
        STATE_INITIAL: map[CharType]State{
            CHAR_NUMBER: STATE_INTEGER,
            CHAR_POINT:  STATE_POINT_WITHOUT_INT,
            CHAR_SIGN:   STATE_INT_SIGN,
        },
        STATE_INT_SIGN: map[CharType]State{
            CHAR_NUMBER: STATE_INTEGER,
            CHAR_POINT:  STATE_POINT_WITHOUT_INT,
        },
        STATE_INTEGER: map[CharType]State{
            CHAR_NUMBER: STATE_INTEGER,
            CHAR_EXP:    STATE_EXP,
            CHAR_POINT:  STATE_POINT,
        },
        STATE_POINT: map[CharType]State{
            CHAR_NUMBER: STATE_FRACTION,
            CHAR_EXP:    STATE_EXP,
        },
        STATE_POINT_WITHOUT_INT: map[CharType]State{
            CHAR_NUMBER: STATE_FRACTION,
        },
        STATE_FRACTION: map[CharType]State{
            CHAR_NUMBER: STATE_FRACTION,
            CHAR_EXP:    STATE_EXP,
        },
        STATE_EXP: map[CharType]State{
            CHAR_NUMBER: STATE_EXP_NUMBER,
            CHAR_SIGN:   STATE_EXP_SIGN,
        },
        STATE_EXP_SIGN: map[CharType]State{
            CHAR_NUMBER: STATE_EXP_NUMBER,
        },
        STATE_EXP_NUMBER: map[CharType]State{
            CHAR_NUMBER: STATE_EXP_NUMBER,
        },
    }
    state := STATE_INITIAL
    for i := 0; i < len(s); i++ {
        typ := toCharType(s[i])
        if _, ok := transfer[state][typ]; !ok {
            return false
        } else {
            state = transfer[state][typ]
        }
    }
    return state == STATE_INTEGER || state == STATE_POINT || state == STATE_FRACTION || state == STATE_EXP_NUMBER || state == STATE_END
}
```

![image-20210825140634069](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210825140634069.png)

### 模拟

```go
func isNumber(s string) bool {
    b:=[]byte(s)
    pre:=b[0]
    hasE:=false
    hasDot:=false
    beforeDot:=-1
    for i,v:=range b{
        if v=='+' || v=='-'{
            if i>0 &&(pre=='+' || pre=='-' || (pre!='e'&&pre!='E')){
                return false
            }
           continue
        }
        if isAlphabet(v) && (v!='e' && v!='E'){
            return false
        }
        
        if hasE && (v=='.' || v=='e' || v=='E'){
            return false
        }
        if hasDot && v=='.'{
            return false
        }
        if pre=='.' && beforeDot==0 && !isDigit(v){
            return false
        }
        if v=='.'{
            hasDot=true
            if beforeDot==1{
                if !isDigit(pre){
                    return false
                }
            }
            if beforeDot==-1{
                beforeDot=0
            }
        }else if v=='E' || v=='e'{
            hasE=true
            if i==0 || (pre!='.' && !isDigit(pre)){
                return false
            }
        }
        if isDigit(v) && beforeDot==-1{
            beforeDot=1
        }
        pre=v
    }
    if pre=='e' || pre=='E' || (pre=='.' && beforeDot==0){
        return false
    } 
    return true
}
func isAlphabet(c byte)bool{
    return (c>='a' && c<='z') || (c>='A' && c<='Z')
}
func isDigit(c byte)bool{
    return c>='0' && c<='9'
}
```

