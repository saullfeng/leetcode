#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度简单1854收藏分享切换为英文接收动态反馈

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

### 双指针迭代

我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。
第二个指针 cur 指向 head，然后不断遍历 cur。
每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。

![迭代.gif](https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode{
    var prev *ListNode
    curr := head
    for curr !=nil{
        next :=curr.Next
        curr.Next =prev
        prev =curr
        curr =next
    }
    return prev
}
```

![image-20210819105905117](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210819105905117.png)

### 递归

1. 终止条件是当前节点或者下一个节点==null
2. 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句
3. ![递归.gif](https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode{
    if head ==nil || head.Next ==nil{
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next =head
    head.Next =nil
    return newHead
}
```

![image-20210819105945784](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210819105945784.png)

### 

