#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

难度简单3592收藏分享切换为英文接收动态反馈

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-105 <= nums[i] <= 105`

 

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

### 动态规划

![image-20210822095940118](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822095940118.png)



```go
func maxSubArray(nums []int) int {
    max :=nums[0]
    for i := 1;i<len(nums);i++{
        //正收益
        if nums[i]+nums[i-1]>nums[i]{
            nums[i] +=nums[i-1]
        }
        //更新
        if nums[i] >max{
            max =nums[i]
        }
    }
    return max
}
```



```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := nums[0]
    ans := nums[0]
    for i := 1; i < len(nums); i++ {
        dp = max(dp+nums[i], nums[i])
        ans = max(ans, dp)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```



![image-20210822102805225](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822102805225.png)

### 分治法

[思路分析]

![/21](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822105638633.png)

![image-20210822105651317](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822105651317.png)

```go
type Status struct {
    lSum, rSum, mSum, iSum int
}
func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
func pushUp(l, r Status) Status {
    iSum := l.iSum + r.iSum
    lSum := max(l.lSum, l.iSum + r.lSum)
    rSum := max(r.rSum, r.iSum + l.rSum)
    mSum := max(max(l.mSum, r.mSum), l.rSum + r.lSum)
    return Status{lSum, rSum, mSum, iSum}
}
func get(nums []int, l, r int) Status {
    if (l == r) {
        return Status{nums[l], nums[l], nums[l], nums[l]}
    }
    m := (l + r) >> 1
    lSub := get(nums, l, m)
    rSub := get(nums, m + 1, r)
    return pushUp(lSub, rSub)
}
func maxSubArray(nums []int) int {
    return get(nums, 0, len(nums) - 1).mSum;
}
```

![image-20210822102825126](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822102825126.png)

![image-20210822110044370](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210822110044370.png)

