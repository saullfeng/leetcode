#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

难度中等1248收藏分享切换为英文接收动态反馈

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

通过次数191,677

提交次数514,705

题目理解

{1，2，3，4}的下一个排序就是这四个数的更大排序=>{1,2,4,3}

如果没有更大的排序则为升序排列如实例2

**我们结合样例来分析，假设样例为 `[1,3,5,4,1]`：**

**从后往前找，找到第一个下降的位置，记为 k。注意k 以后的位置是降序的。 在样例中就是找到 3**

**从 k 往后找，找到最小的比 k 要大的数。 找到 4**

**将两者交换。注意此时 k 以后的位置仍然是降序的。**

**直接将 k 以后的部分翻转（变为升序）。**

即两遍扫描法

注意：如果在步骤 1 中找到头部还没找到，说明该序列已经是字典序最大的排列。按照题意，我们要将数组重新排列成最小的排列。

![fig1](https://assets.leetcode-cn.com/solution-static/31/31.gif)

### 两遍扫描

```java
func nextPermutation(nums []int) {
    n := len(nums)
    i := n - 2
    for i >= 0 && nums[i] >= nums[i+1] {
        i--
    }
    if i >= 0 {
        j := n - 1
        for j >= 0 && nums[i] >= nums[j] {
            j--
        }
        //交换
        nums[i], nums[j] = nums[j], nums[i]
    }
    reverse(nums[i+1:])
}

func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}
```

- 时间复杂度：对数组线性遍历。复杂度为 O(n)
- 空间复杂度：O(1)