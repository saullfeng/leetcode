#### [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

难度简单223收藏分享切换为英文接收动态反馈

集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

### 计数

一个朴素的做法是，使用「哈希表」统计每个元素出现次数，然后在 [1, n][1,n] 查询每个元素的出现次数。

在「哈希表」中出现 2 次的为重复元素，未在「哈希表」中出现的元素为缺失元素。

由于这里数的范围确定为 [1, n][1,n]，我们可以使用数组来充当「哈希表」，以减少「哈希表」的哈希函数执行和冲突扩容的时间开销。

集合 `s` 包含从 `1` 到 `n` 的整数

```go
func findErrorNums(nums []int) []int {
    ans :=make([]int,2)
    sort.Ints(nums)
    pre :=0
    for _,v :=range nums{
        if v ==pre{
            //重复的值显现
            ans[0] =v
        }else if v- pre >1{
            //缺失的值显现
            ans[1] =pre +1
        }
        pre =v
    }
    n :=len(nums)
    //丢失的数字是 n
    if nums[n-1] !=n{
        ans[1] =n
    }
    return ans
}
```

![image-20210828205327725](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210828205327725.png)

###哈希表

```go
func findErrorNums(nums []int) []int {
    cnt :=map[int]int{}
    for _, v:=range nums{
        cnt[v]++
    }
    ans :=make([]int,2)
       for i := 1; i <= len(nums); i++ {
        c :=cnt[i]
        if c==2{
            ans[0]=i
        }
        if c==0{
            ans[1]=i
        }
    }
    return ans
}
```

时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组并填入哈希表，然后遍历从 1 到 n 的每个数寻找错误的集合。

空间复杂度：O(n)，其中 n 是数组nums 的长度。需要创建大小为O(n) 的哈希表。

### 位运算



![image-20210828214738693](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210828214738693.png)

![image-20210828214752164](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210828214752164.png)

```go
func findErrorNums(nums []int) []int {
    xor := 0
    for _, v := range nums {
        xor ^= v
    }
    n := len(nums)
    for i := 1; i <= n; i++ {
        xor ^= i
    }
    lowbit := xor & -xor
    num1, num2 := 0, 0
    for _, v := range nums {
        if v&lowbit == 0 {
            num1 ^= v
        } else {
            num2 ^= v
        }
    }
    for i := 1; i <= n; i++ {
        if i&lowbit == 0 {
            num1 ^= i
        } else {
            num2 ^= i
        }
    }
    for _, v := range nums {
        if v == num1 {
            return []int{num1, num2}
        }
    }
    return []int{num2, num1}
}
```

![image-20210828214801048](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210828214801048.png)

