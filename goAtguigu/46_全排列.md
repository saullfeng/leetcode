#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度中等1455收藏分享切换为英文接收动态反馈

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

### 回溯递归

![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)



```java
func permute(nums []int) [][]int {
    pathNums := make([]int, len(nums))
    result := make([][]int, 0)
    used := make([]bool, len(nums))
    count := 0
    backtrack(&nums, &pathNums, &used, &result, &count)

    return result
}
// 回溯核心
// nums: 原始列表
// pathNums: 路径上的数字
// used: 是否访问过
//// 最终结果
func backtrack(nums *[]int, pathNums *[]int, used *[]bool, result *[][]int, count *int) {
    if *count == len(*nums) {
        tmp := make([]int, len(*nums))
           // 切片底层公用数据，所以要copy
        copy(tmp, *pathNums)
            // 把本次结果追加到最终结果上
        *result = append(*result, tmp)
        return 
    }
// 开始遍历原始数组的每个数字
    for i:=0; i<len(*nums);i++ {
        // 检查是否访问过
        if !(*used)[i] {
            // 没有访问过就选择它，然后标记成已访问过的
            (*used)[i] = true
                // 做选择：将这个数字加入到路径的尾部，这里用数组模拟链表
            (*pathNums)[*count] = (*nums)[i]
            (*count)++
            backtrack(nums, pathNums, used, result, count)
                // 标记成未使用
                // 撤销刚才的选择，也就是恢复操作   
            (*used)[i] = false
            (*count)--
        }
    }
    
}
```

![image-20210817142943340](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210817142943340.png)

### 



