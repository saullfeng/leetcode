#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

难度中等1239收藏分享切换为英文接收动态反馈

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

### dfs

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0

![image-20210820101001490](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820101001490.png)

```go
func numIslands(grid [][]byte) int {
	count := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			if grid[i][j] == '1' {
				dfs(grid, i, j)
				count++
			}
		}
	}
	return count
}

func dfs(grid [][]byte,i,j int){
     //边界问题
    if(i<0||j<0||i>=len(grid)||j>len(grid[0])||grid[i][j]=='0'){
        return
    }
    //下上左右
    grid[i][j]='0'
    dfs(grid,i+1,j)
    dfs(grid,i-1,j)
    dfs(grid,i,j-1)
    dfs(grid,i,j+1)
}
```

![image-20210820100620839](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820100620839.png)

### bfs

同样地，我们也可以使用广度优先搜索代替深度优先搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。

![image-20210820101354214](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820101354214.png)

```go
func numIslands(grid [][]byte) int {
	optionX := []int{0, 1, 0, -1}
	optionY := []int{1, 0, -1, 0}
	m := len(grid)
	if m == 0 {
		return 0
	}
	n := len(grid[0])
	count := 0
	queue := make([][]int, 0)
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == '1' {
				count++
				queue = append(queue, []int{i, j})
				grid[i][j] = '0'
				for len(queue) > 0 {
					now := queue[0]
					queue = queue[1:]
					for k := 0; k < 4; k++ {
						new := []int{now[0] + optionX[k], now[1] + optionY[k]}
						if 0 <= new[0] && new[0] < m && 0 <= new[1] && new[1] < n && grid[new[0]][new[1]] == '1' {
							queue = append(queue, new)
							grid[new[0]][new[1]] = '0'
						}
					}
				}
			}
		}
	}
	return count
}
```

![image-20210820100647815](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210820100647815.png)

