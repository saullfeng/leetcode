#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度中等1962收藏分享切换为英文接收动态反馈

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

有效括号组合需满足：左括号必须以正确的顺序闭合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 

**提示：**

- `1 <= n <= 8`

### 回溯法+剪枝 dfs

![image-20210817135929903](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210817135929903.png)

![image.png](https://pic.leetcode-cn.com/1600428729-tjBQsP-image.png)

![image-20210817135958625](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210817135958625.png)

![image-20210817140010366](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210817140010366.png)

```go
func generateParenthesis(n int) []string {
	res := []string{}

	var dfs func(lRemain int, rRemain int, path string)
      /*
        dfs
        参数：path: 当前加入的串，
              lRemain: (的数量
              rRemain: )的数量
              res: 返回的串
    */
	dfs = func(lRemain int, rRemain int, path string) {
         // 递归结束条件。括号组合为2 * n才是合法的
		if 2*n == len(path) {
			res = append(res, path)
			return
		}
        //// lRemain > 0 说明左括号的数量多于右括号的数量，所以每次左括号的数量-1才能和右括号匹配
		if lRemain > 0 {
			dfs(lRemain-1, rRemain, path+"(")
		}
		if lRemain < rRemain {
			dfs(lRemain, rRemain-1, path+")")
		}
	}
	
	dfs(n, n, "")
	return res
}
```

![image-20210817135602785](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210817135602785.png)

### 



