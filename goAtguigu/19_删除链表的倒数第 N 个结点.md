#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

难度中等1496收藏分享切换为英文接收动态反馈

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

### 快慢指针



![image-20210829112646238](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210829112646238.png)




![p3](https://assets.leetcode-cn.com/solution-static/19/p3.png)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy :=&ListNode{0,head}
    first ,second :=head,dummy
    //first先走n布
    for i:=0;i<n;i++{
        first =first.Next
    }
    //first与second共走 直到first到null
    for ;first !=nil;first=first.Next{
        second =second.Next
    }
     //断开倒数第n的节点连接
    second.Next =second.Next.Next
    return dummy.Next
}
```

- 时间复杂度：O(L)，其中 *L* 是链表的长度。
- 空间复杂度：O(1)

### 栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

![img](https://assets.leetcode-cn.com/solution-static/19/8.png)

【peek】找到但不移除此列表的头(第一个元素)。

【pop】移除顶对象并作为此函数的值返回该对象。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    nodes :=[]*ListNode{}
    dummy :=&ListNode{0,head}
    for node := dummy; node != nil; node = node.Next {
        nodes =append(nodes,node)
    }
    //将倒数第n个数至于栈顶
    prev :=nodes[len(nodes)-1-n]
    //断开倒数第n的节点连接
    prev.Next =prev.Next.Next
    return dummy.Next
}
```

- 时间复杂度：O(L)，其中 L是链表的长度。
- 空间复杂度：O(L)，其中 L是链表的长度。主要为栈的开销。