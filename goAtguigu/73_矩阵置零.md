#### [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)

难度中等528收藏分享切换为英文接收动态反馈

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

**进阶：**

- 一个直观的解决方案是使用  `O(*m**n*)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(*m* + *n*)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-231 <= matrix[i][j] <= 231 - 1`

###使用两个标记变量

思路和算法

在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        //行与列
        int m = matrix.length, n = matrix[0].length;
        //标记行与列
        boolean flagCol0 =false, flagRow0 =false;
        //第一行是否有0
        for(int i =0; i<m;i++){
            if(matrix[i][0]==0){
                flagCol0=true;
            }
        }
        //第一列是否有0
        for(int j =0;j<n;j++){
            if(matrix[0][j]==0){
                flagRow0=true;
            }
        }
        //非第一行与第一列有0则该行的第一行(最左边)该列的第一列（最上边）均为0；
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(matrix[i][j]==0){
                     matrix[i][0]=matrix[0][j]=0;
                }
               
            }
        }
        //填充出现行列为0的行列(非第一行第一列)
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                //如果为true 其本身就是0
                if(matrix[i][0]==0||matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }
        //第一列填充为0
    if(flagCol0){
        for(int i=0;i<m;i++){
            matrix[i][0]=0;
        }
    }
        //第一行填充为0
        if(flagRow0){
        for(int j=0;j<n;j++){
            matrix[0][j]=0;
        }
    }
        
    }
}


```

时间复杂度：O(mn)，其中 m 是矩阵的行数，n是矩阵的列数。我们至多只需要遍历该矩阵两次。

空间复杂度：O(1)。我们只需要常数空间存储若干变量。



### 使用一个标记变量

我们可以对方法进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        //行列
        int m = matrix.length, n = matrix[0].length;
        boolean flagCol0 =false;
        //行与列同时进行 从元素组1开始遍历
        //有0 则立马将最左边与最上面填充为0
        for(int i=0;i<m;i++){
            if(matrix[i][0]==0){
                flagCol0=true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        //填充出现行列为0的行列(第一行第一列的0)
       for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
              //第一列出现0的列 填充为0
        if (flagCol0) {
                matrix[i][0] = 0;
            }
        }
      

    
    }
}

```

时间复杂度：O(mn)，其中 m是矩阵的行数，n 是矩阵的列数。我们至多只需要遍历该矩阵两次。

空间复杂度：O(1)。我们只需要常数空间存储若干变量。

