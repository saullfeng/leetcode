#### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

难度中等325收藏分享切换为英文接收动态反馈

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

**示例 1:**

```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

**示例 2:**

```
输入:
"cccaaa"

输出:
"cccaaa"

解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。
```

**示例 3:**

```
输入:
"Aabb"

输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
```

### 桶排序

由于每个字符在字符串中出现的频率存在上限，因此可以使用桶排序的思想，根据出现次数生成排序后的字符串。具体做法如下：

遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq；

创建桶，存储从 1 到maxFreq 的每个出现频率的字符；

按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。

getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值

```go
func frequencySort(s string) string {
    //hashmap
    cnt :=map[byte]int{}
    //出现最多的元素
    maxFreq :=0
    //遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq
    for i:=range s{
        //每个元素 出现的次数 频率
        cnt[s[i]]++
        //最高
        maxFreq =max(maxFreq,cnt[s[i]])
    }
    //创建桶，存储从 1 到maxFreq 的每个出现频率的字符 创建了到maxFreq+1个桶
    buckets :=make([][]byte,maxFreq+1)
    for ch ,c :=range cnt{
        buckets[c] = append(buckets[c], ch)
    }
    //按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符
    //然后将每个字符按照出现频率拼接到排序后的字符串
        //反转拼接 i第几个桶 j桶里第几个元素
    ans :=make([]byte,0,len(s))
    for i:=maxFreq;i>0;i--{
        for _,ch:=range buckets[i]{
            ans =append(ans,bytes.Repeat([]byte{ch},i)...)
        }
    }
    return string(ans)
}
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

时间复杂度：O(n+k)，其中 nn 是字符串 s的长度，k 是字符串 ss 包含的不同字符的个数。
遍历字符串统计每个字符出现的频率需要 O(n)的时间。
创建桶并将不同字符加入桶需要 O(k)的时间。
生成排序后的字符串，需要 O(k)的时间遍历桶，以及 O(n)的时拼接字符串间。
因此总时间复杂度是 O(n+k)。

空间复杂度：O(n+k)，其中 n 是字符串 s的长度，kk 是字符串 s 包含的不同字符的个数。空间复杂度主要取决于桶和生成的排序后的字符串。



### 按照出现频率排序

![image-20210826214003657](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210826214003657.png)

```go
func frequencySort(s string) string {
    cnt := map[byte]int{}
    for i := range s {
        cnt[s[i]]++
    }

    type pair struct {
        ch  byte
        cnt int
    }
    pairs := make([]pair, 0, len(cnt))
    for k, v := range cnt {
        pairs = append(pairs, pair{k, v})
    }
    sort.Slice(pairs, func(i, j int) bool { return pairs[i].cnt > pairs[j].cnt })

    ans := make([]byte, 0, len(s))
    for _, p := range pairs {
        ans = append(ans, bytes.Repeat([]byte{p.ch}, p.cnt)...)
    }
    return string(ans)
}
```

![image-20210826214044463](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210826214044463.png)
