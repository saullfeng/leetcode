#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度简单631收藏分享切换为英文接收动态反馈

给定一个二叉树，返回它的 *后序* 遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

### 递归



```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) (res []int) {
    var postorder func(node *TreeNode)
    postorder = func(node *TreeNode){
        if node ==nil{
            return
        }
        postorder(node.Left)
        postorder(node.Right)
        res =append(res,node.Val)
    }
    //根节点
    postorder(root)
    return
}
```

![image-20210821165621478](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821165621478.png)

### 迭代

后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) (res []int) {
    stack :=[]*TreeNode{}
    //这个用来记录前一个访问的节点
    var prev *TreeNode
    for root !=nil || len(stack)>0{
        for root !=nil{
            stack=append(stack,root)
            root=root.Left
        }
        //等于stack.pop()
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        //后序遍历的过程中在遍历完左子树跟右子树cur都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。
//如果是从右边再返回根结点，应该回到上层
        if root.Right ==nil || root.Right ==prev{
            res=append(res,root.Val)
            //返回上一个非叶子节点
                //更新下 prev，也就是定位住上一个访问节点
            prev =root
            //有重复
            root=nil
        }else{
            stack=append(stack,root)
            root=root.Right
        }

    }
    return
}
```



![image-20210821165637130](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821165637130.png)

### Morris 遍历

![image-20210821165658932](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821165658932.png)

```go
func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}

func postorderTraversal(root *TreeNode) (res []int) {
    addPath := func(node *TreeNode) {
        resSize := len(res)
        for ; node != nil; node = node.Right {
            res = append(res, node.Val)
        }
        reverse(res[resSize:])
    }

    p1 := root
    for p1 != nil {
        if p2 := p1.Left; p2 != nil {
            for p2.Right != nil && p2.Right != p1 {
                p2 = p2.Right
            }
            if p2.Right == nil {
                p2.Right = p1
                p1 = p1.Left
                continue
            }
            p2.Right = nil
            addPath(p1.Left)
        }
        p1 = p1.Right
    }
    addPath(root)
    return
}
```

![image-20210821165646885](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821165646885.png)
