#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

难度困难1404收藏分享切换为英文接收动态反馈

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

 

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

### 





### 



### 堆 优先队列

用容量为K的最小堆优先队列，把链表的头结点都放进去，然后出队当前优先队列中最小的，挂上链表，，然后让出队的那个节点的下一个入队，再出队当前优先队列中最小的，直到优先队列为空。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
    if lists == nil || len(lists) == 0 {
      return nil // 链表为空或长度为0，直接返回空指针
   }
   var h IntHeap // 最小堆用于维护当前k个节点
   heap.Init(&h) // 用于节点间的比较

   for _, list := range lists {
      // 数组中非空的链表加入到最小堆
      if list != nil {
         heap.Push(&h, list)
      }
   }
   // 定义dummy节点用于统一处理
   dummy := &ListNode{}
   p := dummy // p初始指向dummy节点

   // 当最小堆不为空时，不断执行以下操作
   for h.Len() > 0 { // 取出堆顶元素，即取出最小值节点
      min := heap.Pop(&h).(*ListNode)
      p.Next = min // 游标p指向最小值节点
      p = p.Next   // p向后移动一个位置
      // 这样就确定一个节点在合并链表中的位置
      if min.Next != nil { // 如果最小值节点后面的节点非空
         heap.Push(&h, min.Next) // 则把最小值节点后面的节点加入到最小堆中
      }
   }
   return dummy.Next // 最后只要返回dummy.Next即可
    
}
type IntHeap []*ListNode

func (h IntHeap) Len() int            { return len(h) }
func (h IntHeap) Less(i, j int) bool  { return h[i].Val < h[j].Val }
func (h IntHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
func (h *IntHeap) Pop() interface{} {
   old := *h
   n := len(old)
   x := old[n-1]
   *h = old[0 : n-1]
   return x
}
```

![image-20210821100847116](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821100847116.png)

### 分治

像归并排序一样使用分治法处理，假如k个链表分别为a1, a2, a3,…, ak

不断递归直到只需要处理两个链表的合并，之后两两合并，得到b1, b2 , … , 新链表，

接着继续两两合并得到c1, c2,… 直到最后只剩下一条有序链表。

这个方法在每一层的合并中，都需要处理所有的n个节点，而每次处理后链表的数量变为原来的一半。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

// 辅助函数用于合并两个有序链表
// 辅助函数用于合并两个有序链表
func mergeTwoSortedLists(l1 *ListNode, l2 *ListNode) *ListNode {
   dummy := &ListNode{}
   p := dummy
   for l1 != nil && l2 != nil {
      if l1.Val < l2.Val {
         p.Next = l1
         l1 = l1.Next
      } else {
         p.Next = l2
         l2 = l2.Next
      }
      p = p.Next
   }
   // 连上l1剩余的链,连上l2剩余的链
   if l1 != nil {
      p.Next = l1
   }
   if l2 != nil {
      p.Next = l2
   }
   return dummy.Next
}

// 辅助函数，在还没有达到最基本情况前，不断递归调用自己
// 输入是链表数组，和当前要处理的在链表中开始和结束的下标，输出是合并后的链表
func merge(lists []*ListNode, start, end int) *ListNode {
   if start == end { // 当开始下标等于结束下标时
      return lists[start] // 说明当前要处理的只有一个链表，直接返回它即可
   }
   if start > end { // 否则如果开始下标大于结束下标
      return nil // 无效的，直接返回空指针nil
   }
   // 如果不是上面两种情况，就分而治之
   // 先找到当前子数组的中间下标
   mid := start + (end-start)/2
   // 然后分别递归处理前一半和后一半链表
   left := merge(lists, start, mid)
   right := merge(lists, mid+1, end)
   // 得到的结果是两条合并后的有序链表
   // 最后再把这两条链表也合并即可
   return mergeTwoSortedLists(left, right)
}

// Time: O(n*log(k)), Space: O(log(k))
func mergeKLists(lists []*ListNode) *ListNode {
   if lists == nil || len(lists) == 0 {
      return nil // 链表为空或长度为0，直接返回空指针
   }
   return merge(lists, 0, len(lists)-1)
}
```

![image-20210821103347610](C:\Users\solfeng\AppData\Roaming\Typora\typora-user-images\image-20210821103347610.png)
